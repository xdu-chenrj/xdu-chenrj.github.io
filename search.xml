<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/09/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode第87场双周赛</title>
    <url>/2022/09/22/leetcode%E7%AC%AC87%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="共同度过的日子"><a href="#共同度过的日子" class="headerlink" title="共同度过的日子"></a>共同度过的日子</h2><p>Alice 和 Bob 计划分别去罗马开会。</p>
<p>给你四个字符串 arriveAlice ，leaveAlice ，arriveBob 和 leaveBob 。Alice 会在日期 arriveAlice 到 leaveAlice 之间在城市里（日期为闭区间），而 Bob 在日期 arriveBob 到 leaveBob 之间在城市里（日期为闭区间）。每个字符串都包含 5 个字符，格式为 “MM-DD” ，对应着一个日期的月和日。</p>
<p>请你返回 Alice和 Bob 同时在罗马的天数。</p>
<p>你可以假设所有日期都在 同一个 自然年，而且 不是 闰年。每个月份的天数分别为：[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] 。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：arriveAlice &#x3D; “08-15”, leaveAlice &#x3D; “08-18”, arriveBob &#x3D; “08-16”, leaveBob &#x3D; “08-19”<br>输出：3<br>解释：Alice 从 8 月 15 号到 8 月 18 号在罗马。Bob 从 8 月 16 号到 8 月 19 号在罗马，他们同时在罗马的日期为 8 月 16、17 和 18 号。所以答案为 3 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：arriveAlice &#x3D; “10-01”, leaveAlice &#x3D; “10-31”, arriveBob &#x3D; “11-01”, leaveBob &#x3D; “12-31”<br>输出：0<br>解释：Alice 和 Bob 没有同时在罗马的日子，所以我们返回 0 。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>所有日期的格式均为 “MM-DD” 。</li>
<li>Alice 和 Bob 的到达日期都 早于或等于 他们的离开日期。</li>
<li>题目测试用例所给出的日期均为 非闰年 的有效日期。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> months[<span class="number">13</span>] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">days</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> month, day;</span><br><span class="line">        <span class="built_in">sscanf</span>(s.<span class="built_in">c_str</span>(), <span class="string">&quot;%d-%d&quot;</span>, &amp;month, &amp;day);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; month; i++) &#123;</span><br><span class="line">            sum += months[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sum += day;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDaysTogether</span><span class="params">(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(<span class="built_in">days</span>(leaveAlice), <span class="built_in">days</span>(leaveBob)) - <span class="built_in">max</span>(<span class="built_in">days</span>(arriveAlice), <span class="built_in">days</span>(arriveBob)) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="运动员和训练师的最大匹配数"><a href="#运动员和训练师的最大匹配数" class="headerlink" title="运动员和训练师的最大匹配数"></a>运动员和训练师的最大匹配数</h2><p>给你一个下标从 0 开始的整数数组 players ，其中 players[i] 表示第 i 名运动员的 能力 值，同时给你一个下标从 0 开始的整数数组 trainers ，其中 trainers[j] 表示第 j 名训练师的 训练能力值 。</p>
<p>如果第 i 名运动员的能力值 小于等于 第 j 名训练师的能力值，那么第 i 名运动员可以 匹配 第 j 名训练师。除此以外，每名运动员至多可以匹配一位训练师，每位训练师最多可以匹配一位运动员。</p>
<p>请你返回满足上述要求 players 和 trainers 的 最大 匹配数。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：players &#x3D; [4,7,9], trainers &#x3D; [8,2,5,8]<br>输出：2<br>解释：<br>得到两个匹配的一种方案是：</p>
<p>players[0] 与 trainers[0] 匹配，因为 4 &lt;&#x3D; 8 。</p>
<p>players[1] 与 trainers[3] 匹配，因为 7 &lt;&#x3D; 8 。<br>可以证明 2 是可以形成的最大匹配数。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：players &#x3D; [1,1,1], trainers &#x3D; [10]<br>输出：1<br>解释：<br>训练师可以匹配所有 3 个运动员<br>每个运动员至多只能匹配一个训练师，所以最大答案是 1 。</p>
</blockquote>
<p>提示：</p>
<ul>
<li><code>1 &lt;= players.length, trainers.length &lt;= 105</code></li>
<li><code>1 &lt;= players[i], trainers[j] &lt;= 109</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">matchPlayersAndTrainers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; players, vector&lt;<span class="type">int</span>&gt;&amp; trainers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(players.<span class="built_in">begin</span>(), players.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(trainers.<span class="built_in">begin</span>(), trainers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; players.<span class="built_in">size</span>() &amp;&amp; j &lt; trainers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; trainers.<span class="built_in">size</span>() &amp;&amp; players[i] &gt; trainers[j]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; trainers.<span class="built_in">size</span>() &amp;&amp; trainers[j] &gt;= trainers[i]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="按位或最大的最小子数组长度"><a href="#按位或最大的最小子数组长度" class="headerlink" title="按位或最大的最小子数组长度"></a>按位或最大的最小子数组长度</h2><p>给你一个长度为 n 下标从 0 开始的数组 nums ，数组中所有数字均为非负整数。对于 0 到 n - 1 之间的每一个下标 i ，你需要找出 nums 中一个 最小 非空子数组，它的起始位置为 i （包含这个位置），同时有 最大 的 按位或运算值 。</p>
<ul>
<li>换言之，令 Bij 表示子数组 nums[i…j] 的按位或运算的结果，你需要找到一个起始位置为 i 的最小子数组，这个子数组的按位或运算的结果等于 max(Bik) ，其中 i &lt;&#x3D; k &lt;&#x3D; n - 1 。<br>  一个数组的按位或运算值是这个数组里所有数字按位或运算的结果。</li>
</ul>
<p>请你返回一个大小为 n 的整数数组 answer，其中 answer[i]是开始位置为 i ，按位或运算结果最大，且 最短 子数组的长度。</p>
<p>子数组 是数组里一段连续非空元素组成的序列。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：nums &#x3D; [1,0,2,1,3]<br>输出：[3,3,2,2,1]<br>解释：<br>任何位置开始，最大按位或运算的结果都是 3 。</p>
<ul>
<li>下标 0 处，能得到结果 3 的最短子数组是 [1,0,2] 。</li>
<li>下标 1 处，能得到结果 3 的最短子数组是 [0,2,1] 。</li>
<li>下标 2 处，能得到结果 3 的最短子数组是 [2,1] 。</li>
<li>下标 3 处，能得到结果 3 的最短子数组是 [1,3] 。</li>
<li>下标 4 处，能得到结果 3 的最短子数组是 [3] 。<br>所以我们返回 [3,3,2,2,1] 。</li>
</ul>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：nums &#x3D; [1,2]<br>输出：[2,1]<br>解释：<br>下标 0 处，能得到最大按位或运算值的最短子数组长度为 2 。<br>下标 1 处，能得到最大按位或运算值的最短子数组长度为 1 。<br>所以我们返回 [2,1] 。</p>
</blockquote>
<p><strong>题解：</strong></p>
<p>逆序遍历，因为是要求最短，所以记录每一位的<code>1</code>第一次出现的位置，又因为要求或运算最大，所以还需要对每一位<code>1</code></p>
<p>第一次出现的位置取最大值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">smallestSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">30</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> index = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">30</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt;&gt; j &amp; <span class="number">1</span>) a[j] = i;</span><br><span class="line">                index = <span class="built_in">max</span>(index, a[j]);</span><br><span class="line">            &#125;      </span><br><span class="line">            res[i] = index - i + <span class="number">1</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="完成所有交易的初始最少钱数"><a href="#完成所有交易的初始最少钱数" class="headerlink" title="完成所有交易的初始最少钱数"></a>完成所有交易的初始最少钱数</h2><p>给你一个下标从 0 开始的二维整数数组 transactions，其中transactions[i] &#x3D; [costi, cashbacki] 。</p>
<p>数组描述了若干笔交易。其中每笔交易必须以 某种顺序 恰好完成一次。在任意一个时刻，你有一定数目的钱 money ，为了完成交易 i ，money &gt;&#x3D; costi 这个条件必须为真。执行交易后，你的钱数 money 变成 money - costi + cashbacki 。</p>
<p>请你返回 任意一种 交易顺序下，你都能完成所有交易的最少钱数 money 是多少。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：transactions &#x3D; [[2,1],[5,0],[4,2]]<br>输出：10<br>解释：<br>刚开始 money &#x3D; 10 ，交易可以以任意顺序进行。<br>可以证明如果 money &lt; 10 ，那么某些交易无法进行。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：transactions &#x3D; [[3,0],[0,3]]<br>输出：3<br>解释：</p>
<ul>
<li>如果交易执行的顺序是 [[3,0],[0,3]] ，完成所有交易需要的最少钱数是 3 。</li>
<li>如果交易执行的顺序是 [[0,3],[3,0]] ，完成所有交易需要的最少钱数是 0 。<br>所以，刚开始钱数为 3 ，任意顺序下交易都可以全部完成。</li>
</ul>
</blockquote>
<p><strong>题解：</strong></p>
<p>下一笔交易能够进行一定满足条件</p>
<blockquote>
<p>money - (cost_1 - back_1) + (cost_2 - back_2) … &gt;&#x3D; cost_i</p>
<p>那么money &gt;&#x3D;   (cost_1 - back_1) + (cost_2 - back_2) + cost_i</p>
<p>最少钱数money等于右侧最大值，右侧表示按照某种顺序，进行第i笔交易时，达到了最大钱数。</p>
<p>右侧由两部分组成， (cost_1 - back_1) + (cost_2 - back_2) 和 cost_i</p>
<p>要整体达到最大值，所以这两部分也需要达到最大值。</p>
<p>第一部分，统计所有cost  &gt; back 和合。</p>
<p>第二部分，我们无法直接得出cost_i在哪笔交易中，但是我们可以通过枚举所有交易。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minimumMoney</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; transactions)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : transactions) &#123;</span><br><span class="line">            <span class="type">int</span> cost = p[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> cashback = p[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(cost &gt; cashback) &#123;</span><br><span class="line">                sum += cost - cashback;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : transactions) &#123;</span><br><span class="line">            <span class="type">int</span> cost = p[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> cashback = p[<span class="number">1</span>];</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> s = sum;</span><br><span class="line">            <span class="keyword">if</span>(cost &gt; cashback) &#123;</span><br><span class="line">                s -= cost - cashback;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, s + cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>中国银联专场竞赛（2023届校园招聘专场）</title>
    <url>/2022/10/02/%E4%B8%AD%E5%9B%BD%E9%93%B6%E8%81%94%E4%B8%93%E5%9C%BA%E7%AB%9E%E8%B5%9B%EF%BC%882023%E5%B1%8A%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E4%B8%93%E5%9C%BA%EF%BC%89/</url>
    <content><![CDATA[<h2 id="重构链表"><a href="#重构链表" class="headerlink" title="重构链表"></a>重构链表</h2><p>给定一个链表的头节点 <code>head</code> ，在不改变节点顺序的基础下，请删除链表中所有值为 <code>偶数</code> 的节点，并返回这个链表 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>若链表为空，则返回空值。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<code>head = [1,4,3,6]</code></p>
<p>输出：<code>[1,3]</code></p>
<p>解释：如下图所示，黑色节点的值均为偶数，删除这些节点后，链表为 <code>[1,3]</code><br><img src="https://pic.leetcode-cn.com/1663123060-ffBMiH-image.png" alt="image.png"></p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<code>head = [5,7,9,9,1]</code></p>
<p>输出：<code>[5,7,9,9,1]</code></p>
<p>解释：原链表中不存在值为偶数的节点。</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入：<code>head = [2,4]</code></p>
<p>输出：<code>[]</code></p>
<p>解释：原链表中所有节点值均为偶数。</p>
</blockquote>
<p><strong>提示：</strong><br><code>1 &lt;= head.length &lt;= 10^5</code><br><code>0 &lt;= Node.val &lt;= 100</code></p>
<p>创建虚拟头节点，然后遍历链表，用cur指针去更新虚拟节点的后继。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reContruct</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(head -&gt; val % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                head = head -&gt; next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur -&gt; next = head;</span><br><span class="line">            head = head -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="勘探补给"><a href="#勘探补给" class="headerlink" title="勘探补给"></a>勘探补给</h2><p>工程部在一条坐标轴上设立了若干补给站，<code>station[i]</code> 表示编号为 <code>i</code> 的补给站的坐标。</p>
<p>现在有一些正在执行任务的勘探队需要进行补给，<code>pos[i]</code> 表示第 <code>i</code> 个勘探队当前所在位置的坐标。勘探队将优先选择<strong>当前距离最近</strong>的补给站进行补给。若两座补给站距离相同，则选择坐标更小的那一个。</p>
<p><strong>请按顺序</strong>返回这些勘探队所选择的补给站编号。</p>
<p><strong>注意：</strong></p>
<ul>
<li><code>station</code> 中的元素严格递增，即 <code>station[i] &lt; station[i+1]</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<br><code>station = [2,7,8,10]</code><br><code>pos = [4,9]</code><br>输出：<br><code>[0,2]</code><br>解释：<br>坐标 <code>4</code> 的勘探队与坐标为 <code>2</code> 和 <code>7</code> 的补给站距离分别为 <code>2</code> 和 <code>3</code>， 选择坐标为 <code>2</code>的补给站<br>坐标 <code>9</code> 的勘探队与坐标为 <code>8</code> 和 <code>10</code> 的补给站的距离均为 <code>1</code>， 选择坐标更小为 <code>8</code> 的补给站<br>返回编号为 <code>[0,2]</code> 的补给站。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<br><code>station = [2,5,8,14,17]</code><br><code>pos = [1,14,11,2]</code><br>输出：<br><code>[0,3,2,0]</code></p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= pos.length,station.length &lt;= 10^4</code></li>
<li><code>1 &lt;= pos[i] &lt;= 10^6</code></li>
<li><code>1 &lt;= station[i] &lt; station[i+1] &lt;= 10^6</code></li>
</ul>
<p>模拟即可，寻找的时候用二分即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">explorationSupply</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; station, vector&lt;<span class="type">int</span>&gt;&amp; pos)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = pos.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(station.<span class="built_in">begin</span>(), station.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> front = <span class="built_in">lower_bound</span>(station.<span class="built_in">begin</span>(), station.<span class="built_in">end</span>(), pos[i]) - station.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> back = <span class="built_in">upper_bound</span>(station.<span class="built_in">begin</span>(), station.<span class="built_in">end</span>(), pos[i]) - station.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="comment">// cout &lt;&lt; front &lt;&lt; &#x27; &#x27; &lt;&lt; back &lt;&lt; &#x27; &#x27; &lt;&lt; station[front] &lt;&lt; &#x27; &#x27; &lt;&lt; station[back] &lt;&lt; endl;;</span></span><br><span class="line">            <span class="keyword">if</span>(front != back) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(front);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// front == back</span></span><br><span class="line">                <span class="keyword">if</span>(front == station.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(front - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(pos[i] - station[front - <span class="number">1</span>] != station[back] - pos[i]) &#123;</span><br><span class="line">                        <span class="comment">// cout &lt;&lt; pos[i] &lt;&lt; &#x27; &#x27; &lt;&lt; station[front - 1]  &lt;&lt; &#x27; &#x27; &lt;&lt; pos[i] - station[front - 1] &lt;&lt; &#x27; &#x27; &lt;&lt; station[back] - pos[i] &lt;&lt; endl;</span></span><br><span class="line">                        <span class="keyword">if</span>(pos[i] - station[front - <span class="number">1</span>] &gt; station[back] - pos[i]) &#123;</span><br><span class="line">                            res.<span class="built_in">push_back</span>(back);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            res.<span class="built_in">push_back</span>(front - <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(front - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(front);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="风能发电"><a href="#风能发电" class="headerlink" title="风能发电"></a>风能发电</h2><p>现有一座风力发电场和<strong>容量</strong> <code>storeLimit</code> 的储能站，第 <code>j</code> 条供电指令 <code>supply[j]=[time, minSupply, maxSupply]</code> 表示时刻 <code>time</code> 起（包含该时刻）每一时刻最少供应电能 <code>minSupply</code> 以及最多供应电能 <code>maxSupply</code>，直至后续指令调整。</p>
<p>在时刻 <code>i</code> 发电量为 <code>power[i]</code>，该时刻供电逻辑如下：</p>
<ul>
<li><p>若发电量在 <code>[minSupply, maxSupply]</code> 范围内，则均供应负载；</p>
</li>
<li><p>若发电量大于 <code>maxSupply</code>，则超出部分存入储能站，存储量至多不超过 <code>storeLimit</code>；</p>
</li>
<li><p>若发电量小于</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">minSupply</span><br></pre></td></tr></table></figure>

<p>  ，则由储能站补充缺少电量，最多不超过当前存储量；</p>
<blockquote>
<p>注：储能站补充电量，直至剩余存储电量为 <code>0</code></p>
</blockquote>
</li>
</ul>
<p>请返回最后时刻（即时刻 <code>power.length-1</code>）储能站中能源总量。</p>
<p><strong>注意：</strong></p>
<ul>
<li>输入用例保证供电指令的 <code>time</code> 严格递增且第 <code>0</code> 个指令的 <code>time = 0</code></li>
<li>储能电站初始存储电量为 <code>0</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<br><code>storeLimit = 10</code><br><code>power = [1,3,4,3,6]</code><br><code>supply = [[0,2,3]]</code></p>
<p>输出: <code>4</code></p>
<p>解释：<br>时刻 0，供能 1， 新增储能 0， 总储能 0<br>时刻 1，供能 3， 新增储能 0， 总储能 0<br>时刻 2，供能 3， 新增储能 1， 总储能 1<br>时刻 3，供能 3， 新增储能 0， 总储能 1<br>时刻 4，供能 3， 新增储能 3， 总储能 4<br>因此最后时刻，剩余的能源总量为 4</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<br><code>storeLimit = 6</code><br><code>power = [6,5,2,1,0]</code><br><code>supply = [[0,1,2],[2,3,3]]</code></p>
<p>输出: <code>0</code></p>
<p>解释：<br>时刻 0，供能 2， 新增储能 4， 总储能 4<br>时刻 1，供能 2， 新增储能 2， 总储能 6 (由于储能电站达上限，电量 1 丢弃)<br>时刻 2，供能 3， 新增储能 -1， 总储能 5<br>时刻 3，供能 3， 新增储能 -2， 总储能 3<br>时刻 4，供能 3， 新增储能 -3， 总储能 0<br>因此最后时刻，剩余的能源总量为 0</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= storeLimit &lt;= 10^6</code></li>
<li><code>1 &lt;= power.length &lt;= 10^5</code></li>
<li><code>0 &lt;= power[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= supply.length &lt;= power.length</code></li>
<li>对于 <code>i &lt; j</code>，满足 <code>supply[i][0] &lt; supply[j][0]</code></li>
<li><code>supply[i].length == 3</code></li>
<li><code>0 &lt;= supply[i][0] &lt; power.length</code></li>
<li><code>0 &lt;= supply[i][1]&lt;= supply[i][2] &lt;= 10^5</code></li>
</ul>
<p>也是模拟，用map记录每个时间的最大值和最小值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">StoredEnergy</span><span class="params">(<span class="type">int</span> storeLimit, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; power, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; supply)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; hash;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : supply) &#123;</span><br><span class="line">            hash[p[<span class="number">0</span>]] = <span class="built_in">make_pair</span>(p[<span class="number">1</span>], p[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> store = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> time = supply[<span class="number">0</span>][<span class="number">0</span>], minSupply = supply[<span class="number">0</span>][<span class="number">1</span>], maxSupply = supply[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; power.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[i] != <span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">                time = i;</span><br><span class="line">                minSupply = hash[i].first;</span><br><span class="line">                maxSupply = hash[i].second;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(power[i] &gt;= minSupply &amp;&amp; power[i] &lt;= maxSupply) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(power[i] &gt;= maxSupply) &#123;</span><br><span class="line">                store += power[i] - maxSupply;</span><br><span class="line">                store = <span class="built_in">min</span>(storeLimit, store);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                store -= minSupply - power[i];</span><br><span class="line">                store = <span class="built_in">max</span>(<span class="number">0</span>, store);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> store;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="设计自动售货机"><a href="#设计自动售货机" class="headerlink" title="设计自动售货机"></a>设计自动售货机</h2><p>「银联二维码」支付可以提供简便、顺畅的消费服务，通过出示二维码或扫描二维码即可完成支付。<br>现有一台使用<strong>银联二维码</strong>进行支付的自动售货机，并对使用 银联 支付的用户提供额外的优惠服务。</p>
<blockquote>
<p>同一名顾客每成功购买一次，下次购买便可多享受 1% 的折扣（折后价<strong>向上取整</strong>），最低折扣为 70%</p>
<ul>
<li>即：第一次购买支付 100% 费用，第二次购买支付 99% 费用， 第三次购买支付 98% 费用，以此类推。</li>
</ul>
</blockquote>
<p>请你设计一个自动售货机，你需要实现一个 <code>VendingMachine</code> 类：</p>
<ul>
<li><p><code>VendingMachine()</code> —— 初始化一个 <code>VendingMachine</code> 实例</p>
</li>
<li><p><code>void addItem(int time, int number, string item, int price, int duration)</code></p>
<p> 在<code>time</code>时刻向售货机中增加<code>number</code> 个名称为<code>item</code>的商品，价格为<code>price</code>，保质期为<code>duration</code>。</p>
<ul>
<li>同种商品可能有不同批次，不同批次的价格和保质期可能不同</li>
</ul>
</li>
<li><p><code>long sell(int time, string customer, string item, int number)</code></p>
<p>   —— 在<code>time</code>时刻，名称为<code>customer</code>的顾客前来购买了<code>number</code>个名称为<code>item</code>的商品，返回总费用</p>
<ul>
<li>当且仅当售货机中存在足够数量的未过期商品方可成功购买，并返回支付的总费用，否则一件商品也不会售出，并返回 <code>-1</code></li>
<li>对于价格不同的同种商品，优先售出价格<strong>最低</strong>的商品；</li>
<li>如果有价格相同的同种商品，优先出售<strong>距离过期时间最近</strong>的商品；</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>输入保证前一次操作的 <code>time</code> 不大于后一次操作的 <code>time</code></li>
<li>过期指商品存入的时刻与保质期之和小于当前时刻，也即 <code>addtime + duration &lt; currTime</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<br><code>[&quot;VendingMachine&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;sell&quot;]</code><br><code>[[],[0,3,&quot;Apple&quot;,10,10],[1,&quot;Tom&quot;,&quot;Apple&quot;,1],[2,&quot;Tom&quot;,&quot;Apple&quot;,3],[3,&quot;Mary&quot;,&quot;Banana&quot;,2],[11,&quot;Jim&quot;,&quot;Apple&quot;,1]]</code></p>
<p>输出: <code>[null,null,10,-1,-1,-1]</code></p>
<p>解释：<br><code>VendingMachine sys = new VendingMachine();</code><br><code>sys.addItem(0,3,&quot;Apple&quot;,10,10);</code> &#x2F;&#x2F; 时刻 <code>0</code> ，添加 <code>3</code> 个 <code>Apple</code>，价格为 <code>10</code>，保质期为 <code>10</code>。<br><code>sys.sell(1,&quot;Tom&quot;,&quot;Apple&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>1</code> ，用户 <code>Tom</code> 购买 <code>1</code> 个 <code>Apple</code>， 支付 <code>10</code> ：。<br><code>sys.sell(2,&quot;Tom&quot;,&quot;Apple&quot;,3);</code> &#x2F;&#x2F; 时刻 <code>2</code> ，售货机中 <code>Apple</code> 数量为 <code>2</code> ，用户 <code>Tom</code> 购买失败，返回 <code>-1</code>。<br><code>sys.sell(3,&quot;Mary&quot;,&quot;Banana&quot;,2);</code> &#x2F;&#x2F; 时刻 <code>3</code> ，售货机中没有 <code>Banana</code> ，用户 <code>Mary</code> 购买失败，返回 <code>-1</code>。<br><code>sys.sell(11,&quot;Jim&quot;,&quot;Apple&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>11</code> ，售货机中的 <code>Apple</code> 全部过期，用户 <code>Jim</code> 购买失败，返回 <code>-1</code>。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<br><code>[&quot;VendingMachine&quot;,&quot;addItem&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;sell&quot;]</code><br><code>[[],[0,1,&quot;Apple&quot;,4,3],[1,3,&quot;Apple&quot;,4,2],[2,&quot;Mary&quot;,&quot;Apple&quot;,2],[2,1,&quot;Banana&quot;,2,5],[4,&quot;Jim&quot;,&quot;Banana&quot;,2],[4,&quot;Mary&quot;,&quot;Banana&quot;,1],[4,&quot;Mary&quot;,&quot;Apple&quot;,1],[6,200,&quot;Apple&quot;,2,5],[6,&quot;Jim&quot;,&quot;Apple&quot;,100],[7,&quot;Mary&quot;,&quot;Apple&quot;,100]]</code></p>
<p>输出: <code>[null,null,null,8,null,-1,2,-1,null,200,196]</code></p>
<p>解释：<br><code>VendingMachine sys = new VendingMachine();</code><br><code>sys.addItem(0,1,&quot;Apple&quot;,4,3);</code> &#x2F;&#x2F; 时刻 <code>0</code> ，添加 <code>1</code> 个 <code>Apple</code>，价格为 <code>4</code>，保质期为 <code>3</code>。<br><code>sys.addItem(1,3,&quot;Apple&quot;,4,2);</code> &#x2F;&#x2F; 时刻 <code>1</code> ，添加 <code>3</code> 个 <code>Apple</code>，价格为 <code>4</code>，保质期为 <code>2</code>。<br><code>sys.sell(2,&quot;Mary&quot;,&quot;Apple&quot;,2);</code> &#x2F;&#x2F; 时刻 <code>2</code> ，用户 <code>Mary</code> 购买 <code>2</code> 个 <code>Apple</code>，支付 <code>8</code>。<br><code>sys.addItem(2,1,&quot;Banana&quot;,2,5);</code> &#x2F;&#x2F; 时刻 <code>2</code> ，添加 <code>1</code> 个 <code>Banana</code>，价格为 <code>2</code>，保质期为 <code>5</code>。<br><code>sys.sell(4,&quot;Jim&quot;,&quot;Banana&quot;,2);</code> &#x2F;&#x2F; 时刻 <code>4</code> ，售货机中 <code>Banana</code> 数量为 <code>1</code> ，用户 <code>Jim</code> 购买失败，返回 <code>-1</code>。<br><code>sys.sell(4,&quot;Mary&quot;,&quot;Banana&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>4</code> ，用户 <code>Mary</code> 购买 <code>1</code> 个 <code>Banana</code>，享受 1% 的优惠，向上取整后为 <code>2</code><br><code>sys.sell(4,&quot;Mary&quot;,&quot;Apple&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>4</code> ，售货机中的 <code>Apple</code> 全部过期，用户 <code>Mary</code> 购买失败，返回 <code>-1</code>。<br><code>sys.addItem(6,200,&quot;Apple&quot;,2,5);</code> &#x2F;&#x2F; 时刻 <code>6</code> ，添加 <code>200</code> 个 <code>Apple</code>，价格为 <code>2</code>，保质期为 <code>5</code>。<br><code>sys.sell(6,&quot;Jim&quot;,&quot;Apple&quot;,100);</code> &#x2F;&#x2F; 时刻 <code>6</code> ，用户 <code>Jim</code> 购买 <code>100</code> 个 <code>Apple</code>。返回 200<br><code>sys.sell(7,&quot;Mary&quot;,&quot;Apple&quot;,100);</code> &#x2F;&#x2F; 时刻 <code>7</code> ，用户 <code>Mary</code> 购买 <code>100</code> 个 <code>Apple</code>，可享受 2% 的优惠。返回196</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= item.length,customer.length &lt;= 10</code>，<code>item</code> 和 <code>customer</code> 中只包含英文字母</li>
<li><code>1 &lt;= duration,price,number &lt;= 10^6</code></li>
<li><code>0 &lt;= time &lt;= 10^6</code></li>
<li><code>addItem</code> 和 <code>sell</code> 的总调用次数不超过 <code>1000</code> 次</li>
</ul>
<p>关键是如何高效存储信息。</p>
<p>因为不能出售过期商品，而且售卖时间是递增的，所以每次售卖遍历过期商品的操作是多余，我们可以在售卖前删除过期商品，删除后本次遍历的商品都是可以购买的，不用担心过期问题。为了方便的去掉过期商品，可以创建<code>tuple&lt;time, item, price</code>小根堆，堆内会依次对关键词排序，实际我们只关心<code>time</code>，去除的时候只需要挨个遍历，堆内的<code>time</code>是递增的；</p>
<p>出售时，获取<code>item</code>在不同<code>&#123;end_time, price&#125;</code>的数量，可以用<code>map</code>来存储；</p>
<p>因为只有数量够客户的购买量，才会更新<code>item</code>的信息，如果在最后一步才发现数量不够，还需要回退更新操作，比较麻烦，而且时间上可能会超时，所以用<code>map</code>标记一下每个<code>item</code>的总量，如果数量够则放心更新信息，不够则直接返回<code>-1</code>；</p>
<p>因为客户每成功购买一次商品折扣就要少一个点，所以用<code>map</code>标记一下<code>customer</code>成功购买次数；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VendingMachine</span> &#123;</span><br><span class="line">    priority_queue&lt;tuple&lt;<span class="type">int</span>, string, <span class="type">int</span>&gt;, vector&lt;tuple&lt;<span class="type">int</span>, string, <span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt; item_time;</span><br><span class="line">    map&lt;string, map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt;&gt; item_info; </span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; user_cnt;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; item_cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VendingMachine</span>() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addItem</span><span class="params">(<span class="type">int</span> time, <span class="type">int</span> number, string item, <span class="type">int</span> price, <span class="type">int</span> duration)</span> </span>&#123;</span><br><span class="line">        item_time.<span class="built_in">push</span>(<span class="built_in">make_tuple</span>(time + duration, item, price));</span><br><span class="line">        item_info[item][<span class="built_in">make_pair</span>(price, time + duration)] += number;</span><br><span class="line">        item_cnt[item] += number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sell</span><span class="params">(<span class="type">int</span> time, string customer, string item, <span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!item_time.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(item_time.<span class="built_in">top</span>()) &lt; time) &#123;</span><br><span class="line">            <span class="type">int</span> _time = <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(item_time.<span class="built_in">top</span>());</span><br><span class="line">            string _item = <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(item_time.<span class="built_in">top</span>());</span><br><span class="line">            <span class="type">int</span> _price = <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(item_time.<span class="built_in">top</span>());</span><br><span class="line">            item_cnt[_item] -= item_info[_item][<span class="built_in">make_pair</span>(_price, _time)];</span><br><span class="line">            item_info[_item].<span class="built_in">erase</span>(<span class="built_in">make_pair</span>(_price, _time));</span><br><span class="line">            item_time.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(item_cnt[item] &lt; number) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> buy_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> price = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(buy_cnt &lt; number) &#123;</span><br><span class="line">            <span class="type">int</span> _price = item_info[item].<span class="built_in">begin</span>() -&gt; first.first;</span><br><span class="line">            <span class="type">int</span> _time = item_info[item].<span class="built_in">begin</span>() -&gt; first.second;</span><br><span class="line">            <span class="type">int</span> _num = item_info[item].<span class="built_in">begin</span>() -&gt; second;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;_num &quot; &lt;&lt; _num &lt;&lt; &quot; &quot;;</span></span><br><span class="line">            item_info[item].<span class="built_in">erase</span>(<span class="built_in">make_pair</span>(_price, _time));</span><br><span class="line">            <span class="type">int</span> cnt = <span class="built_in">min</span>(number - buy_cnt, _num);</span><br><span class="line">            buy_cnt += cnt;</span><br><span class="line">            price += <span class="number">1ll</span> * cnt * _price;</span><br><span class="line">            <span class="keyword">if</span>(_num &gt; cnt) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;item_info[item][make_pair(_price, _time)] &quot; &lt;&lt; item_info[item][make_pair(_price, _time)] &lt;&lt; endl;</span></span><br><span class="line">                item_info[item][<span class="built_in">make_pair</span>(_price, _time)] = _num - cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        item_cnt[item] -= number;</span><br><span class="line">        price = (price * <span class="built_in">max</span>(<span class="number">70</span>, (<span class="number">100</span> - user_cnt[customer])) - <span class="number">1</span>) * <span class="number">0.01</span> + <span class="number">1</span>;</span><br><span class="line">        user_cnt[customer] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your VendingMachine object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * VendingMachine* obj = new VendingMachine();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addItem(time,number,item,price,duration);</span></span><br><span class="line"><span class="comment"> * long long param_2 = obj-&gt;sell(time,customer,item,number);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>leetcode第331场周赛</title>
    <url>/2022/09/19/leetcode%E7%AC%AC311%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="最小偶倍数"><a href="#最小偶倍数" class="headerlink" title="最小偶倍数"></a>最小偶倍数</h2><p>给你一个正整数 <code>n</code> ，返回 <code>2</code> 和 <code>n</code> 的最小公倍数（正整数）。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：n &#x3D; 5<br>输出：10<br>解释：5 和 2 的最小公倍数是 10 。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：n &#x3D; 6<br>输出：6<br>解释：6 和 2 的最小公倍数是 6 。注意数字会是它自身的倍数。</p>
</blockquote>
<p>提示</p>
<blockquote>
<p>1 &lt;&#x3D; n &lt;&#x3D; 150</p>
</blockquote>
<p>直接gcd就可以，但是有一个数是2是确定的，这个2比较特殊。所以有另一种写法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y == <span class="number">0</span> ? x : <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestEvenMultiple</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="number">2</span> / <span class="built_in">gcd</span>(<span class="number">2</span>, n); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestEvenMultiple</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span>) <span class="keyword">return</span> n * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="最长的字母序连续字符串的长度"><a href="#最长的字母序连续字符串的长度" class="headerlink" title="最长的字母序连续字符串的长度"></a>最长的字母序连续字符串的长度</h2><p><strong>字母序连续字符串</strong> 是由字母表中连续字母组成的字符串。换句话说，字符串</p>
<blockquote>
<p>“abcdefghijklmnopqrstuvwxyz”</p>
</blockquote>
<p>的任意字符串都是<strong>字母序连续字符串</strong> 。</p>
<ul>
<li>例如，”abc” 是一个字母序连续字符串，而 “acb” 和 “za” 不是。</li>
<li>给你一个仅由小写英文字母组成的字符串 s ，返回其 最长 的 字母序连续子字符串 的长度。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：s &#x3D; “abacaba”<br>输出：2<br>解释：共有 4 个不同的字母序连续子字符串 “a”、”b”、”c” 和 “ab” 。<br>“ab” 是最长的字母序连续子字符串。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：s &#x3D; “abcde”<br>输出：5<br>解释：”abcde” 是最长的字母序连续子字符串。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<p>直接比较一下就行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestContinuousSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mxlen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] - s[i - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                mxlen++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, mxlen);</span><br><span class="line">                mxlen = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ans, mxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="翻转二叉树的奇数层"><a href="#翻转二叉树的奇数层" class="headerlink" title="翻转二叉树的奇数层"></a>翻转二叉树的奇数层</h2><p>给你一棵<strong>完美</strong>二叉树的根节点 root ，请你反转这棵树中每个<strong>奇数</strong>层的节点值。</p>
<ul>
<li>例如，假设第 3 层的节点值是 [2,1,3,4,7,11,29,18] ，那么反转后它应该变成 [18,29,11,7,4,3,1,2] 。<br>  反转后，返回树的根节点。</li>
</ul>
<p><strong>完美</strong>二叉树需满足：二叉树的所有父节点都有两个子节点，且所有叶子节点都在同一层。</p>
<p>节点的<strong>层数</strong>等于该节点到根节点之间的边数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/07/28/first_case1.png" alt="img"></p>
<blockquote>
<p>输入：root &#x3D; [2,3,5,8,13,21,34]<br>输出：[2,5,3,8,13,21,34]<br>解释：<br>这棵树只有一个奇数层。<br>在第 1 层的节点分别是 3、5 ，反转后为 5、3 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/07/28/second_case3.png" alt="img"></p>
<blockquote>
<p>输入：root &#x3D; [7,13,11]<br>输出：[7,11,13]<br>解释：<br>在第 1 层的节点分别是 13、11 ，反转后为 11、13 。 </p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数目在范围 <code>[1, 214]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 105</code></li>
<li><code>root</code> 是一棵 <strong>完美</strong> 二叉树</li>
</ul>
<p><strong>DFS</strong>，搜的时候把当前深度传进去，如果当前深度是基数，交换两个节点的val。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* left, TreeNode* right, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!left) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(d % <span class="number">2</span>) <span class="built_in">swap</span>(left-&gt;val, right-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(left-&gt;left, right-&gt;right, d + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(left-&gt;right, right-&gt;left, d + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reverseOddLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, root-&gt;right, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="字符串的前缀分数和"><a href="#字符串的前缀分数和" class="headerlink" title="字符串的前缀分数和"></a>字符串的前缀分数和</h2><p>给你一个长度为 n 的数组 words ，该数组由<strong>非空</strong>字符串组成。</p>
<p>定义字符串 word 的<strong>分数</strong>等于以 word 作为 前缀 的 words[i] 的数目。</p>
<ul>
<li>例如，如果 words &#x3D; [“a”, “ab”, “abc”, “cab”] ，那么 “ab” 的分数是 2 ，因为 “ab” 是 “ab” 和 “abc” 的一个前缀。</li>
</ul>
<p>返回一个长度为 n 的数组 answer ，其中 answer[i] 是 words[i] 的每个非空前缀的分数 总和 。</p>
<p><strong>注意</strong>：字符串视作它自身的一个前缀。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：words &#x3D; [“abc”,”ab”,”bc”,”b”]<br>输出：[5,4,3,2]<br>解释：对应每个字符串的答案如下：</p>
<p>“abc” 有 3 个前缀：”a”、”ab” 和 “abc” 。</p>
<p>2 个字符串的前缀为 “a” ，2 个字符串的前缀为 “ab” ，1 个字符串的前缀为 “abc” 。<br>总计 answer[0] &#x3D; 2 + 2 + 1 &#x3D; 5 。</p>
<p>“ab” 有 2 个前缀：”a” 和 “ab” 。</p>
<p>2 个字符串的前缀为 “a” ，2 个字符串的前缀为 “ab” 。<br>总计 answer[1] &#x3D; 2 + 2 &#x3D; 4 。</p>
<p>“bc” 有 2 个前缀：”b” 和 “bc” 。</p>
<p>2 个字符串的前缀为 “b” ，1 个字符串的前缀为 “bc” 。<br>总计 answer[2] &#x3D; 2 + 1 &#x3D; 3 。</p>
<p>“b” 有 1 个前缀：”b”。</p>
<p>2 个字符串的前缀为 “b” 。<br>总计 answer[3] &#x3D; 2 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：words &#x3D; [“abcd”]<br>输出：[4]<br>解释：<br>“abcd” 有 4 个前缀 “a”、”ab”、”abc” 和 “abcd”。<br>每个前缀的分数都是 1 ，总计 answer[0] &#x3D; 1 + 1 + 1 + 1 &#x3D; 4 。</p>
</blockquote>
<p>建<strong>Trie</strong>，统计。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> tr[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; word)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> u = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!tr[p][u]) &#123;</span><br><span class="line">                tr[p][u] = ++idx;</span><br><span class="line">            &#125;</span><br><span class="line">            p = tr[p][u];</span><br><span class="line">            cnt[p]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string&amp; word)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> u = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            p = tr[p][u];</span><br><span class="line">            res += cnt[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sumPrefixScores</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(tr, <span class="number">0</span> , <span class="keyword">sizeof</span> tr);</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        <span class="keyword">for</span>(string&amp; word : words) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(string&amp; word : words) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">query</span>(word));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Trie</tag>
        <tag>Binary tree</tag>
        <tag>Number Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>第313场周赛</title>
    <url>/2022/10/02/leetcode%E7%AC%AC313%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="公因子的数目"><a href="#公因子的数目" class="headerlink" title="公因子的数目"></a><a href="https://leetcode.cn/problems/number-of-common-factors/">公因子的数目</a></h2><p>给你两个正整数 <code>a</code> 和 <code>b</code> ，返回 <code>a</code> 和 <code>b</code> 的 <strong>公</strong> 因子的数目。</p>
<p>如果 <code>x</code> 可以同时整除 <code>a</code> 和 <code>b</code> ，则认为 <code>x</code> 是 <code>a</code> 和 <code>b</code> 的一个 <strong>公因子</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：a = 12, b = 6</span><br><span class="line">输出：4</span><br><span class="line">解释：12 和 6 的公因子是 1、2、3、6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：a = 25, b = 30</span><br><span class="line">输出：2</span><br><span class="line">解释：25 和 30 的公因子是 1、5 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= a, b &lt;= 1000</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">commonFactors</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a % i == <span class="number">0</span> &amp;&amp; b % i == <span class="number">0</span>) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="沙漏的最大总和"><a href="#沙漏的最大总和" class="headerlink" title="沙漏的最大总和"></a><a href="https://leetcode.cn/problems/maximum-sum-of-an-hourglass/">沙漏的最大总和</a></h2><p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>grid</code> 。</p>
<p>按以下形式将矩阵的一部分定义为一个 <strong>沙漏</strong> ：</p>
<p><img src="https://assets.leetcode.com/uploads/2022/08/21/img.jpg" alt="img"></p>
<p>返回沙漏中元素的 <strong>最大</strong> 总和。</p>
<p><strong>注意：</strong>沙漏无法旋转且必须整个包含在矩阵中。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/08/21/1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]</span><br><span class="line">输出：30</span><br><span class="line">解释：上图中的单元格表示元素总和最大的沙漏：6 + 2 + 1 + 2 + 9 + 2 + 8 = 30 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/08/21/2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：35</span><br><span class="line">解释：上图中的单元格表示元素总和最大的沙漏：1 + 2 + 3 + 5 + 7 + 8 + 9 = 35 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>3 &lt;= m, n &lt;= 150</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 106</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; m - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> s = grid[i][j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j - <span class="number">1</span>; k &lt; j - <span class="number">1</span> + <span class="number">3</span>; k++) &#123;</span><br><span class="line">                    s += grid[i - <span class="number">1</span>][k] + grid[i + <span class="number">1</span>][k];</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="最小-XOR"><a href="#最小-XOR" class="headerlink" title="最小 XOR"></a><a href="https://leetcode.cn/problems/minimize-xor/">最小 XOR</a></h2><p>给你两个正整数 <code>num1</code> 和 <code>num2</code> ，找出满足下述条件的整数 <code>x</code> ：</p>
<ul>
<li><code>x</code> 的置位数和 <code>num2</code> 相同，且</li>
<li><code>x XOR num1</code> 的值 <strong>最小</strong></li>
</ul>
<p>注意 <code>XOR</code> 是按位异或运算。</p>
<p>返回整数 <code>x</code> 。题目保证，对于生成的测试用例， <code>x</code> 是 <strong>唯一确定</strong> 的。</p>
<p>整数的 <strong>置位数</strong> 是其二进制表示中 <code>1</code> 的数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num1 = 3, num2 = 5</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">num1 和 num2 的二进制表示分别是 0011 和 0101 。</span><br><span class="line">整数 3 的置位数与 num2 相同，且 3 XOR 3 = 0 是最小的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num1 = 1, num2 = 12</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">num1 和 num2 的二进制表示分别是 0001 和 1100 。</span><br><span class="line">整数 3 的置位数与 num2 相同，且 3 XOR 1 = 2 是最小的。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num1, num2 &lt;= 109</code></li>
</ul>
<p>位运算，<code>^</code>运算相同为0，不同为1，要让最终的<code>^</code>结果最小，用尽量多的<code>1</code>从高位开始去占高位的<code>1</code>，这样会抹掉高位的<code>1</code>，如果还有多余的<code>1</code>，那就从低位开始，占低位的<code>0</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimizeXor</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num2 &amp; <span class="number">1</span>) cnt++;</span><br><span class="line">            num2 &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span> &amp;&amp; cnt &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num1 &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span> &amp;&amp; cnt &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(num1 &gt;&gt; i &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="对字母串可执行的最大删除数"><a href="#对字母串可执行的最大删除数" class="headerlink" title="对字母串可执行的最大删除数"></a>对字母串可执行的最大删除数</h2><p>给你一个仅由小写英文字母组成的字符串 <code>s</code> 。在一步操作中，你可以：</p>
<ul>
<li>删除 <strong>整个字符串</strong> <code>s</code> ，或者</li>
<li>对于满足 <code>1 &lt;= i &lt;= s.length / 2</code> 的任意 <code>i</code> ，如果 <code>s</code> 中的 <strong>前</strong> <code>i</code> 个字母和接下来的 <code>i</code> 个字母 <strong>相等</strong> ，删除 <strong>前</strong> <code>i</code> 个字母。</li>
</ul>
<p>例如，如果 <code>s = &quot;ababc&quot;</code> ，那么在一步操作中，你可以删除 <code>s</code> 的前两个字母得到 <code>&quot;abc&quot;</code> ，因为 <code>s</code> 的前两个字母和接下来的两个字母都等于 <code>&quot;ab&quot;</code> 。</p>
<p>返回删除 <code>s</code> 所需的最大操作数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcabcdabc&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">- 删除前 3 个字母（&quot;abc&quot;），因为它们和接下来 3 个字母相等。现在，s = &quot;abcdabc&quot;。</span><br><span class="line">- 删除全部字母。</span><br><span class="line">一共用了 2 步操作，所以返回 2 。可以证明 2 是所需的最大操作数。</span><br><span class="line">注意，在第二步操作中无法再次删除 &quot;abc&quot; ，因为 &quot;abc&quot; 的下一次出现并不是位于接下来的 3 个字母。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aaabaab&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">- 删除第一个字母（&quot;a&quot;），因为它和接下来的字母相等。现在，s = &quot;aabaab&quot;。</span><br><span class="line">- 删除前 3 个字母（&quot;aab&quot;），因为它们和接下来 3 个字母相等。现在，s = &quot;aab&quot;。 </span><br><span class="line">- 删除第一个字母（&quot;a&quot;），因为它和接下来的字母相等。现在，s = &quot;ab&quot;。</span><br><span class="line">- 删除全部字母。</span><br><span class="line">一共用了 4 步操作，所以返回 4 。可以证明 4 是所需的最大操作数。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aaaaa&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：在每一步操作中，都可以仅删除 s 的第一个字母。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 4000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<p>字符串哈希，线性动态规划。</p>
<p>用字符串<code>hash</code>通过<code>O(n^2)</code>的预处理，可以在<code>O(1)</code>的时间内查询两个字符串是否相同。</p>
<p><code>f[i]</code>表示删掉<code>i</code>后缀用的最大操作次数。</p>
<p>枚举后缀长度<code>j</code>，如果<code>i</code>开始长度为<code>j</code>的字符串可以删除，</p>
<p>表示<code>[i, i + j - 1]</code>和<code>[i + j, i + j + j -1]</code>的字符串是相同的，</p>
<p>那么后缀<code>i</code>的删除次数可以增加一次，可以更新最大删除次数：<code>f[i] = max(f[i], f[i + j] + 1)</code>，</p>
<p>对每一个<code>i</code>枚举所有合法的长度<code>j</code>，取最大值，便是<code>f[i]</code>，删除<code>i</code>后缀的最大操作次数。</p>
<p>时间复杂度为<code>O(n^2)</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> P = <span class="number">131</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> h[<span class="number">4005</span>], p[<span class="number">4005</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">            h[i] = h[i - <span class="number">1</span>] * P + s[i - <span class="number">1</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            f[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= (n - i + <span class="number">1</span>) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">get</span>(i, i + j - <span class="number">1</span>) == <span class="built_in">get</span>(i + j, i + j + j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    f[i] = <span class="built_in">max</span>(f[i], f[i + j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">1</span>];    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
