<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AQS</title>
    <url>/2023/05/06/AQS/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Arrays类的copyOf方法</title>
    <url>/2023/05/03/Arrays%E7%B1%BB%E7%9A%84copyOf%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>ArrayList</title>
    <url>/2023/05/02/ArrayList/</url>
    <content><![CDATA[<h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p><code>ArrayList</code>的底层是一个被<code>transisent</code>修饰的<code>Object</code>动态数组，在添加元素前使用<code>ensureCapacity</code>方法来确保数组的容量可以放下当前元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p><code>ArrayList</code>有三个构造函数，无参数直接初始化，指定大小初始化，指定初始元素初始化</p>
<ul>
<li>无参构造函数初始化时候，会初始化赋值一个空数组，当向数组添加第一个元素时，数组容量被扩为<code>10</code>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  首先会调用确保内部容量<code>ensureCapacityInternal</code>方法  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <code>ensureCapacityINternal</code>方法调用了确保显示容量<code>ensureExplicitCapacity</code>方法，<code>ensureExplicitCapacity</code>方法参数为<code>calculateCapacity</code>的返回值，<code>calculateCapacity</code>返回最小容量，如果传入的数组为默认空数组，即数组中还没有一个元素，则返回的最小容量是<code>Math.max(DEFAULT_CAPACITY, minCapacity)</code>,即10，否则返回传入的<code>minCapacity</code>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  如果算出的最小容量大于当前数组的长度，则进行扩容。  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  首先算出新的容量，新的容量为1.5倍的数组长度，然后将新的容量和算出来的最小容量比较，如果新容量小于算出的最小容量，则把算出来的最小容量当做新容量。新容量如果大于<code>MAX_ARRAY_SIZE</code>即<code>Integer.MAX_VALUE - 8</code>，那么重新使用<code>hugeCapacity</code>方法根据最小容量计算新的容量，如果最小容量大于<code>MAX_ARRAY_SIZE</code>则使用<code>Integer.MAX_VALUE</code>作为新容量，否则使用<code>MAX_ARRAY_SIZE</code>作为新容量。  最后调用<code>Arrays.copyOf</code>复制。  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <strong>总结</strong>：首先会算一个最小容量，当数组为空时，最小容量为<code>0</code>，否则为当前数组长度加一，当数组如果这个最小容量大于当前数组的长度，则进行扩容。  扩容的时候首先会计算一个新容量，新的容量是1.5倍的数组长度，算出来的新容量可能还没有算出来的最小容量大，这个时候新容量的大小就是算出来的最小容量，然后将算出来的新容量如果大于数组最大长度，则需要重新计算，新容量最大为<code>Integer.MAX_VALUE</code>，即<code>0x7fffffff</code>。</li>
</ul>
<h3 id="插入元素和删除元素的时间复杂度"><a href="#插入元素和删除元素的时间复杂度" class="headerlink" title="插入元素和删除元素的时间复杂度"></a>插入元素和删除元素的时间复杂度</h3><p><code>ArrayList</code>的<code>add(E e)</code>方法默认是追加到数组末尾，因此时间复杂度为<code>O(1)</code>，但是要指定在某个下标下添加元素或删除元素，时间复杂度是<code>O(n)</code>，因为要把下标后的元素统一向前调整或向后调整</p>
<h3 id="ArrayList中存储数据的Object-elementData为什么使用transisent关键词修饰"><a href="#ArrayList中存储数据的Object-elementData为什么使用transisent关键词修饰" class="headerlink" title="ArrayList中存储数据的Object[] elementData为什么使用transisent关键词修饰"></a>ArrayList中存储数据的Object[] elementData为什么使用transisent关键词修饰</h3><p>结论：节省空间</p>
<p>由于<code>ArrayList</code>的数组是基于动态扩建的，所以并不是所有被分配的内存空间都存储了数据。如果采用外部序列化实现数组的序列化，会序列化整个数组，<code>ArrayList</code>为了避免不必要的序列化，内部提供了<code>writeObject</code>以及<code>readObject</code>来实现自我序列化和反序列化。</p>
<p>1、首先被<code>transisent</code>修饰的成员变量不会被序列化</p>
<p>2、<code>ArrayList</code>实现了<code>Serializable</code>接口，实现<code>Serializable</code>接口，使用<code>ObjectOutputStream.writeObject(Object object)</code>写对象，使用<code>ObjectInputStream.readObject()</code>读对象信息</p>
<p>3、<code>ObjectOutputStream.writeObject(Object object)</code>首先会判断<code>enableOverride</code>属性是否为<code>true</code>，如果是，反射调用重写的<code>writeObject</code>方法完成序列化，否则调用默认的序列化方法完成序列化，反序列化也是如此。</p>
<h3 id="ArrayList线程安全问题"><a href="#ArrayList线程安全问题" class="headerlink" title="ArrayList线程安全问题"></a>ArrayList线程安全问题</h3><p><code>ArrayList</code>是线程不安全的，因为添加和删除方法并没有加锁，或者其他额外操作来确保线程安全</p>
<h3 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a>ArrayList和Vector的区别</h3><ul>
<li><p>接口实现：<code>ArrayList</code>和<code>Vector</code>都是<code>List</code>接口的主要实现类</p>
</li>
<li><p>底层数据结构：两者都是用<code>Object[]</code>来存储元素的</p>
</li>
<li><p>线程安全：<code>ArrayList</code>是线程不安全的，而<code>Vector</code>是线程安全的，<code>Vector</code>的关键方法都使用了<code>synchronized</code>关键字来修饰</p>
</li>
<li><p>是否支持快速随机访问：两者都实现了<code>RandomAccess</code>接口，因此都支持快速随机访问</p>
</li>
<li><p>插入和删除时间复杂度：<code>ArrayList</code></p>
</li>
</ul>
<h3 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h3><ul>
<li>线程安全：都是线程不安全的</li>
<li>底层数据结构：<code>ArrayListLinkedList</code>底层使用了<code>Object[]</code>，<code>LinkedList</code>底层使用的是双向链表（JDK1.6之前为循环链表，1.7之后删除了循环）</li>
<li>是否支持快速随机访问：<code>ArrayList</code>因为底层是数组所以支持随机访问，而<code>LinkedList</code>底层是链表的原因不支持随机访问</li>
<li>空间占用：<code>ArrayList</code>会在结尾预留一定的空间而造成一定的浪费，而<code>LinkedList</code>每一个元素要比<code>ArrayList</code>多前驱和后继</li>
<li><strong>插入和删除的时间复杂度</strong>：<code>LinkedList</code>采用链表存储，插入删除元素的时间复杂度不受元素位置的影响，都是近似<code>O(1)</code>，但是如何对指定下标进行插入和删除，时间复杂度是<code>O(n)</code>，因为首先需要遍历到制定下标。</li>
</ul>
]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
        <tag>Java集合</tag>
        <tag>Jdk源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Atomic原子类</title>
    <url>/2023/05/06/Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>CompletableFuture</title>
    <url>/2023/05/06/CompletableFuture/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>ConcurrentHashMap</title>
    <url>/2023/05/06/ConcurrentHashMap/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Dubbo-SPI</title>
    <url>/2023/05/02/Dubbo-SPI/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/2023/05/05/HTTP/</url>
    <content><![CDATA[<h3 id="从输入URL到页面展示发生了什么？"><a href="#从输入URL到页面展示发生了什么？" class="headerlink" title="从输入URL到页面展示发生了什么？"></a>从输入URL到页面展示发生了什么？</h3><h3 id="HTTP和HTTPS有什么区别"><a href="#HTTP和HTTPS有什么区别" class="headerlink" title="HTTP和HTTPS有什么区别?"></a>HTTP和HTTPS有什么区别?</h3><h3 id="HTTP1-0和HTTP1-1有什么区别？"><a href="#HTTP1-0和HTTP1-1有什么区别？" class="headerlink" title="HTTP1.0和HTTP1.1有什么区别？"></a>HTTP1.0和HTTP1.1有什么区别？</h3><h3 id="HTTP1-1和HTTP2-0有什么区别？"><a href="#HTTP1-1和HTTP2-0有什么区别？" class="headerlink" title="HTTP1.1和HTTP2.0有什么区别？"></a>HTTP1.1和HTTP2.0有什么区别？</h3><h3 id="HTTP2-0和HTTP3-0有什么区别？"><a href="#HTTP2-0和HTTP3-0有什么区别？" class="headerlink" title="HTTP2.0和HTTP3.0有什么区别？"></a>HTTP2.0和HTTP3.0有什么区别？</h3><h3 id="Cookie和Session有什么区别？"><a href="#Cookie和Session有什么区别？" class="headerlink" title="Cookie和Session有什么区别？"></a>Cookie和Session有什么区别？</h3><h3 id="URL和URI有什么区别"><a href="#URL和URI有什么区别" class="headerlink" title="URL和URI有什么区别?"></a>URL和URI有什么区别?</h3>]]></content>
      <categories>
        <category>计算机网路</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap详解</title>
    <url>/2023/04/06/HashMap%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="HashMap的底层结构"><a href="#HashMap的底层结构" class="headerlink" title="HashMap的底层结构"></a>HashMap的底层结构</h3><p>jdk1.7中，HashMap是由数组加链表组成的，数组是主体，链表主要是为了解决hash冲突。</p>
<p>jdk1.8中，HashMap是由数组、链表加红黑树组成。当链表过长，则会严重影响HashMap的性能，红黑树的查询时间复杂度O(log n)，而链表的查询时间复杂度为O(n)。1.8中，链表和红黑树在达到一定条件会自动进行转换：</p>
<ul>
<li>当链表长度达到8时，且数据总量<code>&gt;=</code>64会转红黑树</li>
<li>当链表长度达到8时，数据总量<code>&lt;</code>64会直接扩容</li>
</ul>
<h3 id="HashMap的线程安全性"><a href="#HashMap的线程安全性" class="headerlink" title="HashMap的线程安全性"></a>HashMap的线程安全性</h3><h3 id="HashMap的key索引计算"><a href="#HashMap的key索引计算" class="headerlink" title="HashMap的key索引计算"></a>HashMap的key索引计算</h3><h3 id="HashMap的put操作"><a href="#HashMap的put操作" class="headerlink" title="HashMap的put操作"></a>HashMap的put操作</h3><h3 id="HashMap的get操作"><a href="#HashMap的get操作" class="headerlink" title="HashMap的get操作"></a>HashMap的get操作</h3><h3 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h3><h3 id="HashMap的冲突解决"><a href="#HashMap的冲突解决" class="headerlink" title="HashMap的冲突解决"></a>HashMap的冲突解决</h3><p>解决Hash冲突的办法有：</p>
<ul>
<li>开放地址法:</li>
<li>拉链法：使用链表等数据结构将哈希冲突的键值对连接在一起，当出现冲突时，将新的键值对插入到该位置对应的料表中。<ul>
<li>再哈希法：当哈希冲突发生时，选择另一个哈希函数来计算新哈希值，直到找到没有冲突的索引下标。需要设计多种哈希函数。</li>
</ul>
</li>
<li>建立公共溢出区：</li>
</ul>
<h3 id="HashMap的默认加载因子"><a href="#HashMap的默认加载因子" class="headerlink" title="HashMap的默认加载因子"></a>HashMap的默认加载因子</h3><h3 id="HashMap的Key类型选择"><a href="#HashMap的Key类型选择" class="headerlink" title="HashMap的Key类型选择"></a>HashMap的Key类型选择</h3><h3 id="HashMap为什么不直接用红黑树，而是先用链表再转红黑树"><a href="#HashMap为什么不直接用红黑树，而是先用链表再转红黑树" class="headerlink" title="HashMap为什么不直接用红黑树，而是先用链表再转红黑树"></a>HashMap为什么不直接用红黑树，而是先用链表再转红黑树</h3><h3 id="HashMap的长度为什么是2的幂次方"><a href="#HashMap的长度为什么是2的幂次方" class="headerlink" title="HashMap的长度为什么是2的幂次方"></a>HashMap的长度为什么是2的幂次方</h3>]]></content>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM垃圾回收器CMS和G1的区别</title>
    <url>/2023/04/23/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8CMS%E5%92%8CG1%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>JVM中的类文件</title>
    <url>/2023/05/06/JVM%E4%B8%AD%E7%9A%84%E7%B1%BB%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>JVM垃圾回收机制</title>
    <url>/2023/05/06/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>JVM垃圾回收算法</title>
    <url>/2023/04/23/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>JVM类加载器</title>
    <url>/2023/05/06/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>JVM类加载机制</title>
    <url>/2023/04/23/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>JVM重要参数</title>
    <url>/2023/04/29/JVM%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java-IO中的设计模式</title>
    <url>/2023/05/06/Java-IO%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java-IO模型</title>
    <url>/2023/05/06/Java-IO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java-IO基础知识.md</title>
    <url>/2023/05/06/Java-IO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-md/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java-SPI</title>
    <url>/2023/05/06/Java-SPI/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java代理模式</title>
    <url>/2023/05/06/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java中的锁</title>
    <url>/2023/04/18/Java%E4%B8%AD%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><h4 id="公平锁：线程A获取了锁资源之后，线程B没有拿到，线程B去排队，线程C来了，锁被A持有，同时线程B在排队，线程C直接排到线程B后面，等待线程B拿到锁资源或者B取消后，才尝试竞争锁资源"><a href="#公平锁：线程A获取了锁资源之后，线程B没有拿到，线程B去排队，线程C来了，锁被A持有，同时线程B在排队，线程C直接排到线程B后面，等待线程B拿到锁资源或者B取消后，才尝试竞争锁资源" class="headerlink" title="公平锁：线程A获取了锁资源之后，线程B没有拿到，线程B去排队，线程C来了，锁被A持有，同时线程B在排队，线程C直接排到线程B后面，等待线程B拿到锁资源或者B取消后，才尝试竞争锁资源"></a>公平锁：线程A获取了锁资源之后，线程B没有拿到，线程B去排队，线程C来了，锁被A持有，同时线程B在排队，线程C直接排到线程B后面，等待线程B拿到锁资源或者B取消后，才尝试竞争锁资源</h4><h4 id="非公平锁：线程A获取到了锁资源，线程B没有拿到，线程B去排队，线程C来了，先尝试竞争一下锁资源"><a href="#非公平锁：线程A获取到了锁资源，线程B没有拿到，线程B去排队，线程C来了，先尝试竞争一下锁资源" class="headerlink" title="非公平锁：线程A获取到了锁资源，线程B没有拿到，线程B去排队，线程C来了，先尝试竞争一下锁资源"></a>非公平锁：线程A获取到了锁资源，线程B没有拿到，线程B去排队，线程C来了，先尝试竞争一下锁资源</h4><blockquote>
<h4 id="拿到锁资源：插队成功"><a href="#拿到锁资源：插队成功" class="headerlink" title="拿到锁资源：插队成功"></a>拿到锁资源：插队成功</h4><h4 id="没有拿到锁资源：依然要排到线程B后面，等线程B拿到锁资源或者取消，才尝试去竞争锁资源"><a href="#没有拿到锁资源：依然要排到线程B后面，等线程B拿到锁资源或者取消，才尝试去竞争锁资源" class="headerlink" title="没有拿到锁资源：依然要排到线程B后面，等线程B拿到锁资源或者取消，才尝试去竞争锁资源"></a>没有拿到锁资源：依然要排到线程B后面，等线程B拿到锁资源或者取消，才尝试去竞争锁资源</h4></blockquote>
<blockquote>
<p>Java提供的synchronized只能是非公平锁</p>
<p>Java提供的ReentrantLock、ReentrantReadWriteLock可以实现公平锁和非公平锁</p>
</blockquote>
<h3 id="可重入锁与不可重入锁"><a href="#可重入锁与不可重入锁" class="headerlink" title="可重入锁与不可重入锁"></a>可重入锁与不可重入锁</h3><h4 id="可重入：当前线程获取A锁之后，在获取之后尝试再次获取A锁是可以直接拿到的"><a href="#可重入：当前线程获取A锁之后，在获取之后尝试再次获取A锁是可以直接拿到的" class="headerlink" title="可重入：当前线程获取A锁之后，在获取之后尝试再次获取A锁是可以直接拿到的"></a>可重入：当前线程获取A锁之后，在获取之后尝试再次获取A锁是可以直接拿到的</h4><h4 id="不可重入：当前线程获取A锁之后，尝试再次获取A锁是无法获取到的。"><a href="#不可重入：当前线程获取A锁之后，尝试再次获取A锁是无法获取到的。" class="headerlink" title="不可重入：当前线程获取A锁之后，尝试再次获取A锁是无法获取到的。"></a>不可重入：当前线程获取A锁之后，尝试再次获取A锁是无法获取到的。</h4><blockquote>
<p>Java中的synchronized，ReentrantLock，ReentrantReadWriteLock都是可重入式锁</p>
</blockquote>
<h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><h4 id="悲观锁：获取不到锁资源的时候会将当前线程挂起，线程挂起会涉及到用户态和内核态之间的切换，这种切换是非常消耗资源的。"><a href="#悲观锁：获取不到锁资源的时候会将当前线程挂起，线程挂起会涉及到用户态和内核态之间的切换，这种切换是非常消耗资源的。" class="headerlink" title="悲观锁：获取不到锁资源的时候会将当前线程挂起，线程挂起会涉及到用户态和内核态之间的切换，这种切换是非常消耗资源的。"></a>悲观锁：获取不到锁资源的时候会将当前线程挂起，线程挂起会涉及到用户态和内核态之间的切换，这种切换是非常消耗资源的。</h4><h4 id="线程切换引起内核态切换的原因？"><a href="#线程切换引起内核态切换的原因？" class="headerlink" title="线程切换引起内核态切换的原因？"></a>线程切换引起内核态切换的原因？</h4><p>当一个线程需要访问内核资源时，需要通过系统调用进入内核态来访问内核资源，比如IO操作。如果此时线程被挂起，会从内核态切回用户态，当挂起线程被重新唤醒，它将再次进入内核态。</p>
<blockquote>
<h4 id="用户态和内核态转换需要消耗的资源？"><a href="#用户态和内核态转换需要消耗的资源？" class="headerlink" title="用户态和内核态转换需要消耗的资源？"></a>用户态和内核态转换需要消耗的资源？</h4><p>1、CPU时间：在用户态和内核态进行切换时，CPU需要执行额外的指令，包括保存和恢复现场，这些指令会占用CPU时间，导致性能下降</p>
<p>2、上下文切换开销：当操作系统在不同的线程进行切换时，需要上下文切换，这会涉及到保存当前线程的上下文，然后加载新线程的上下文。</p>
</blockquote>
<h4 id="乐观锁：获取不到锁资源，可再次尝试让CPU调度，重新获取锁资源"><a href="#乐观锁：获取不到锁资源，可再次尝试让CPU调度，重新获取锁资源" class="headerlink" title="乐观锁：获取不到锁资源，可再次尝试让CPU调度，重新获取锁资源"></a>乐观锁：获取不到锁资源，可再次尝试让CPU调度，重新获取锁资源</h4><blockquote>
<p>Java提供的CAS操作就是一种乐观锁的一种实现方式 </p>
<p>Atomic原子类中也是基于CAS乐观锁来实现的</p>
</blockquote>
<h3 id="互斥锁与共享锁"><a href="#互斥锁与共享锁" class="headerlink" title="互斥锁与共享锁"></a>互斥锁与共享锁</h3><h4 id="互斥锁：同一个时间，只会有一个线程持有当前互斥锁"><a href="#互斥锁：同一个时间，只会有一个线程持有当前互斥锁" class="headerlink" title="互斥锁：同一个时间，只会有一个线程持有当前互斥锁"></a>互斥锁：同一个时间，只会有一个线程持有当前互斥锁</h4><h4 id="共享锁：同一个时间，当前共享锁可以被多个线程同时持有"><a href="#共享锁：同一个时间，当前共享锁可以被多个线程同时持有" class="headerlink" title="共享锁：同一个时间，当前共享锁可以被多个线程同时持有"></a>共享锁：同一个时间，当前共享锁可以被多个线程同时持有</h4><blockquote>
<p>共享锁一般配置读写锁来实现的，读写锁互斥，读读锁共享</p>
</blockquote>
<blockquote>
<p>Java提供的sychnronized、ReentrantLock是互斥锁</p>
<p>Java提供的ReentrantReadWriteLock有互斥锁也有共享锁</p>
</blockquote>
]]></content>
      <tags>
        <tag>Java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java值传递</title>
    <url>/2023/05/06/Java%E5%80%BC%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java反射机制</title>
    <url>/2023/05/06/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java并发容器和同步容器</title>
    <url>/2023/05/03/Java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java引用</title>
    <url>/2023/04/30/Java%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java泛型和通配符</title>
    <url>/2023/05/06/Java%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java深拷贝和浅拷贝</title>
    <url>/2023/05/02/Java%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java线程池</title>
    <url>/2023/04/29/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发编程</category>
        <category>Java线程池</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>Java线程池</tag>
        <tag>Java</tag>
        <tag>池化技术</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU</title>
    <url>/2023/04/29/LRU/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LFU</title>
    <url>/2023/04/29/LFU/</url>
    <content><![CDATA[<h3 id="LFU算法原理"><a href="#LFU算法原理" class="headerlink" title="LFU算法原理"></a>LFU算法原理</h3><p><code>LFU</code>的全称是<code>least frequently used</code>，中文翻译为最不经常使用，是<code>redis</code>内存淘汰机制之一，当<code>redis</code>内存不够用时，会淘汰<strong>最不经常使用</strong>的数据，如果有相同最少使用次数的数据，便会应用<code>LRU</code>算法（全称是<code>least recently used</code>，中文名为<strong>最近最少使用</strong>），淘汰最近最少使用的数据，即<strong>最近使用时间靠前的数据</strong>。</p>
<p>我们可以使用一个<code>Node</code>结构体来存储一个数据的所有数据，包括<code>key</code>，<code>value</code>，<code>time</code>，<code>cnt</code>等。</p>
<p><code>time</code>表示数据最后一次被使用的时间，<code>cnt</code>表示数据被使用的次数。</p>
<p>并对结构体重载了小于号，方便每次在有序集合<code>set</code>里都能以<code>O(1)</code>的时间淘汰数据。</p>
<p>使用<code>map</code>来存储<code>key</code>对应的<code>Node</code>，用有序集合<code>set</code>存储所有的数据。</p>
<ul>
<li><p>初始化</p>
<p>  初始化的时候，<code>set</code>和<code>map</code>都清空，<code>time</code>全局变量置为<code>0</code>，全局变量<code>capacity</code>初始化成传进来的值</p>
</li>
<li><p><code>get</code>操作</p>
<p>  如果容量为容量为<code>0</code>，则返回<code>-1</code></p>
<p>  在<code>hash</code>表中查看是否存在<code>key</code>，如果有，取出<code>hash</code>表对应的<code>value</code>数据，然后更新的其时间和使用次数，然后重新在<code>set</code>集合中插入更新后的数据，在重新插入之前需要删除旧数据。</p>
</li>
<li><p><code>put</code>操作</p>
<p>  如果容量为<code>0</code>，无法插入</p>
<p>  如果插入前<code>hash</code>表中存在<code>key</code>则需要更新操作，与<code>get</code>操作类似</p>
<p>  如果插入前<code>hash</code>表中不存在<code>key</code>则需要先判断<code>hash</code>表的容量是否已经达到了最大容量，如果达到了则首先需要删除数据，需要删除<code>set</code>集合的头数据，以及<code>hash</code>表中<code>set</code>集合的头数据的<code>key</code></p>
</li>
</ul>
<h3 id="C-算法实现"><a href="#C-算法实现" class="headerlink" title="C++算法实现"></a>C++算法实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> time, cnt;</span><br><span class="line">    <span class="type">int</span> key, value;</span><br><span class="line">    <span class="built_in">Node</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _cnt, <span class="type">int</span> _time, <span class="type">int</span> _key, <span class="type">int</span> _value):<span class="built_in">cnt</span>(_cnt), <span class="built_in">time</span>(_time), <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node&amp; y) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt == y.cnt ? time &lt; y.time : cnt &lt; y.cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> capacity, time;</span><br><span class="line">    set&lt;Node&gt; S;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Node&gt; hash;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LFUCache</span>(<span class="type">int</span> _capacity) &#123;</span><br><span class="line">        capacity = _capacity;</span><br><span class="line">        S.<span class="built_in">clear</span>();</span><br><span class="line">        hash.<span class="built_in">clear</span>();  </span><br><span class="line">        time = <span class="number">0</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(capacity == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = hash.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it == hash.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node node = it-&gt;second;</span><br><span class="line">        S.<span class="built_in">erase</span>(node);</span><br><span class="line">        node.cnt += <span class="number">1</span>;</span><br><span class="line">        node.time = ++time;</span><br><span class="line">        S.<span class="built_in">insert</span>(node);</span><br><span class="line">        it-&gt;second = node;</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(capacity == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = hash.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it == hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(capacity == hash.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                hash.<span class="built_in">erase</span>(S.<span class="built_in">begin</span>() -&gt; key);</span><br><span class="line">                S.<span class="built_in">erase</span>(S.<span class="built_in">begin</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            Node node = <span class="built_in">Node</span>(<span class="number">1</span>, ++time, key, value);</span><br><span class="line">            hash[key] = node;</span><br><span class="line">            S.<span class="built_in">insert</span>(node);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node node = it-&gt;second;</span><br><span class="line">            S.<span class="built_in">erase</span>(node);</span><br><span class="line">            node.cnt += <span class="number">1</span>;</span><br><span class="line">            node.time = ++time;</span><br><span class="line">            node.value = value;</span><br><span class="line">            S.<span class="built_in">insert</span>(node);</span><br><span class="line">            it-&gt;second = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache* obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LRU</tag>
        <tag>LFU</tag>
        <tag>redis</tag>
        <tag>缓存淘汰算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-MVCC</title>
    <url>/2023/05/06/Mysql-MVCC/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Mysql事务</title>
    <url>/2023/04/26/Mysql%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Mysql</category>
        <category>Mysql事务</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql执行计划分析</title>
    <url>/2023/05/04/Mysql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Mysql基础</title>
    <url>/2023/05/04/Mysql%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Mysql的Buffer Pool</title>
    <url>/2023/05/01/Mysql%E7%9A%84Buffer-Pool/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Mysql日志</title>
    <url>/2023/04/26/Mysql%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Mysql索引失效问题</title>
    <url>/2023/05/01/Mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Mysql索引</title>
    <url>/2023/04/26/Mysql%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h3 id="索引是什么？"><a href="#索引是什么？" class="headerlink" title="索引是什么？"></a>索引是什么？</h3><p>索引是一种数据结构。数据库索引是数据库管理系统中一个排序数据结构，用于加速数据查询。</p>
<h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><p>数据库中的索引好比书中的目录，加快数据的检索</p>
<h3 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h3><ul>
<li><p>时间方面：创建和维护索引需要耗费时间，当表中的数据进行增、删、改的时候索引需要动态维护</p>
</li>
<li><p>空间方面：索引需要占用物理空间</p>
</li>
</ul>
<h3 id="如何创建一个索引"><a href="#如何创建一个索引" class="headerlink" title="如何创建一个索引"></a>如何创建一个索引</h3><h3 id="如何查看Mysql语句有没有用到索引"><a href="#如何查看Mysql语句有没有用到索引" class="headerlink" title="如何查看Mysql语句有没有用到索引"></a>如何查看Mysql语句有没有用到索引</h3><h3 id="创建索引的注意事项有哪些"><a href="#创建索引的注意事项有哪些" class="headerlink" title="创建索引的注意事项有哪些"></a>创建索引的注意事项有哪些</h3><h4 id="选择合适的字段创建索引"><a href="#选择合适的字段创建索引" class="headerlink" title="选择合适的字段创建索引"></a>选择合适的字段创建索引</h4><h4 id="频繁更新的字段谨慎建立索引"><a href="#频繁更新的字段谨慎建立索引" class="headerlink" title="频繁更新的字段谨慎建立索引"></a>频繁更新的字段谨慎建立索引</h4><h4 id="限制每张表的索引数量"><a href="#限制每张表的索引数量" class="headerlink" title="限制每张表的索引数量"></a>限制每张表的索引数量</h4><h4 id="尽可能的考虑建立联合索引而不是单列索引"><a href="#尽可能的考虑建立联合索引而不是单列索引" class="headerlink" title="尽可能的考虑建立联合索引而不是单列索引"></a>尽可能的考虑建立联合索引而不是单列索引</h4><h4 id="避免冗余索引"><a href="#避免冗余索引" class="headerlink" title="避免冗余索引"></a>避免冗余索引</h4><h4 id="字符串类型的数据使用前缀索引"><a href="#字符串类型的数据使用前缀索引" class="headerlink" title="字符串类型的数据使用前缀索引"></a>字符串类型的数据使用前缀索引</h4><h4 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h4><h4 id="删除长期未使用的索引"><a href="#删除长期未使用的索引" class="headerlink" title="删除长期未使用的索引"></a>删除长期未使用的索引</h4><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>在使用联合索引时，<code>Mysql</code>会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直到联合索引中的全部字段匹配完毕，或者在执行过程中遇到范围查询如<code>&gt;</code>，<code>&lt;</code>才会停止匹配。</p>
<p>对于<code>&gt;=</code>，<code>&lt;=</code>，<code>like</code>，<code>between</code>的范围查询，并不会停止匹配。</p>
<h3 id="什么时候会发生索引失效"><a href="#什么时候会发生索引失效" class="headerlink" title="什么时候会发生索引失效"></a>什么时候会发生索引失效</h3><h3 id="Mysql的索引类型有哪些？"><a href="#Mysql的索引类型有哪些？" class="headerlink" title="Mysql的索引类型有哪些？"></a>Mysql的索引类型有哪些？</h3><p>根据数据结构层次可以划分为：</p>
<ul>
<li><code>Hash</code>索引：通过键的<code>hash</code>值快速定位</li>
<li><code>BTree</code>索引：<code>Mysql</code>的存储引擎<code>InoDB</code>实现的是其变种<code>B+Tree</code></li>
<li>全文索引：对文本的内容进行分词，进行搜索。目前只有<code>CHAR</code>，<code>VARCHAR</code>，<code>TEXT</code>列上可以创建全文索引。一般不同，使用<code>es</code>替代。</li>
</ul>
<p>根据应用层次分为：</p>
<ul>
<li><p>主键索引：加速查询、列值唯一且不能为<code>NULL</code>、表中只能存在一个主键索引</p>
<blockquote>
<p><code>InnoDB</code>引擎中，如果没有显示指定表的主键时，<code>InnoDB</code>会自动检查表中是否有唯一索引且不存在<code>NULL</code>值的字段，如果有则选择该字段为默认的主键，否则自动创建一个6<code>Byte</code>的自增主键</p>
</blockquote>
</li>
<li><p>普通索引：仅加速查询、一张表允许多个普通索引</p>
</li>
<li><p>唯一索引：加速查询、列值唯一且可以为<code>NULL</code>、一张表可以有多个唯一索引，建立唯一索引的目的大多数为了该属性列数据的唯一性，而非查询效率</p>
</li>
<li><p>覆盖索引：一个索引包含了所有需要查询的字段的值</p>
</li>
<li><p>联合索引：多个列组成一个索引</p>
</li>
<li><p>前缀索引：前缀索引只适用于字符串类型的数据。前缀索引是对字符串的前几个字符创建索引，相比普通索引建立的数据更小</p>
</li>
<li><p>辅助索引：叶子节点存储主键，唯一索引，普通索引，前缀索引等索引都属于辅助索引</p>
</li>
</ul>
<p>根据底层数据存储方式层次可以分为：</p>
<ul>
<li>聚簇索引：索引结构和数据一起存放，<code>InnoDB</code>中的主键索引属于聚簇索引，相比非聚簇索引，聚簇索引大多数情况会少一次读取数据的IO操作</li>
<li>非聚簇索引：索引结构和数据分开存放，二级索引就属于非聚簇索引，因为叶子节点只存主键不存数据，所以大多数情况下会进行一次回表操作</li>
</ul>
<h3 id="非聚簇索引不一定引发回表"><a href="#非聚簇索引不一定引发回表" class="headerlink" title="非聚簇索引不一定引发回表"></a>非聚簇索引不一定引发回表</h3><p>当聚簇索引是覆盖索引的时候不会发生回表</p>
<h3 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h3><h4 id="Hash索引的底层实现"><a href="#Hash索引的底层实现" class="headerlink" title="Hash索引的底层实现"></a>Hash索引的底层实现</h4><p>哈希表是键值对的集合，通过键的<code>hash</code>值可以快速找到其位置，因此哈希表可以在接近<code>O(1)</code>的时间复杂度快速检索到数据，时间复杂度取决于<code>hash</code>函数。</p>
<h4 id="B树索引的底层实现"><a href="#B树索引的底层实现" class="headerlink" title="B树索引的底层实现"></a>B树索引的底层实现</h4><h4 id="B-树索引的底层实现"><a href="#B-树索引的底层实现" class="headerlink" title="B+树索引的底层实现"></a>B+树索引的底层实现</h4><h5 id="B-树插入操作"><a href="#B-树插入操作" class="headerlink" title="B+树插入操作"></a>B+树插入操作</h5><h5 id="B-树的删除操作"><a href="#B-树的删除操作" class="headerlink" title="B+树的删除操作"></a>B+树的删除操作</h5>]]></content>
      <categories>
        <category>Mysql</category>
        <category>索引</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>索引</tag>
        <tag>B树</tag>
        <tag>B+树</tag>
        <tag>Hash索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty如何解决粘包和拆包问题</title>
    <url>/2023/04/30/Netty%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Mysql锁</title>
    <url>/2023/04/26/Mysql%E9%94%81/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Netty存在的意义</title>
    <url>/2023/05/06/Netty%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Netty应用场景</title>
    <url>/2023/05/06/Netty%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Netty心跳机制</title>
    <url>/2023/05/06/Netty%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Netty服务端和客户端启动过程</title>
    <url>/2023/05/06/Netty%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Netty线程模型</title>
    <url>/2023/05/06/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Netty的核心组件</title>
    <url>/2023/05/06/Netty%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Netty长连接</title>
    <url>/2023/05/06/Netty%E9%95%BF%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Netty零拷贝</title>
    <url>/2023/05/06/Netty%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>RPC的原理</title>
    <url>/2023/05/06/RPC%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>RPC</title>
    <url>/2023/04/28/RPC/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SQL语句在Mysql中的执行过程</title>
    <url>/2023/05/04/SQL%E8%AF%AD%E5%8F%A5%E5%9C%A8Mysql%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Socket网络通信</title>
    <url>/2023/05/11/Socket%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h3 id="Socket网络通信的整体流程"><a href="#Socket网络通信的整体流程" class="headerlink" title="Socket网络通信的整体流程"></a>Socket网络通信的整体流程</h3><p>1、建立服务端并监听客户端请求</p>
<p>2、客户端请求并与服务端建立连接</p>
<p>3、两端之间进行数据传输</p>
<p>4、关闭资源</p>
<h4 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h4><p>1、创建<code>ServerSocket</code>对象并绑定<code>ip</code>和端口号<code>port</code>，<code>server.bind(new InetSocketAddress(host, port))</code></p>
<p>2、通过<code>accept</code>方法监听客户端请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((socket = server.accept()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、连接建立后通过输入流读取客户端发送的请求信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(socket.getInputStream());</span><br><span class="line">                <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) objectInputStream.readObject();</span><br></pre></td></tr></table></figure>

<p>4、通过输出流向客户端发送响应数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(socket.getOutputStream());</span><br><span class="line">message.setConnect(message.getConnect() + <span class="string">&quot; hello&quot;</span>);</span><br><span class="line">objectOutputStream.writeObject(message);</span><br><span class="line">objectOutputStream.flush();</span><br></pre></td></tr></table></figure>

<p>5、关闭资源</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建ServerSocket对象并绑定一个端口</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port)) &#123;</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="comment">// 通过accept方法监听客户端请求</span></span><br><span class="line">            <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;connect success&quot;</span>);</span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(socket.getInputStream());</span><br><span class="line">                <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) objectInputStream.readObject();</span><br><span class="line">                <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(socket.getOutputStream());</span><br><span class="line">                log.info(<span class="string">&quot;server receive &quot;</span> + message.getConnect());</span><br><span class="line">                message.setConnect(message.getConnect() + <span class="string">&quot; hello&quot;</span>);</span><br><span class="line">                objectOutputStream.writeObject(message);</span><br><span class="line">                objectOutputStream.flush();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;occur exception &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 创建 socket 连接</span></span><br><span class="line">            <span class="type">HelloServer</span> <span class="variable">helloServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServer</span>();</span><br><span class="line">            helloServer.start(<span class="number">8888</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>1、创建<code>Socket</code>对象并且连接指定的服务器地址<code>ip</code>和端口号<code>port</code>，<code>Socket socket = new Socket(host, port)</code></p>
<p>2、建立连接后，通过输出流向服务端发送请求信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(socket.getOutputStream());</span><br><span class="line"><span class="comment">// 通过输出流向服务发送请求信息</span></span><br><span class="line">objectOutputStream.writeObject(message);</span><br></pre></td></tr></table></figure>

<p>3、通过输入流获取服务器响应信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(socket.getInputStream());</span><br><span class="line"><span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> objectInputStream.readObject();</span><br></pre></td></tr></table></figure>

<p>4、关闭资源</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">send</span><span class="params">(Message message, String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建socket对象，并制定服务所在地址和端口号</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(host, port))&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(socket.getOutputStream());</span><br><span class="line">            <span class="comment">// 通过输出流向服务发送请求信息</span></span><br><span class="line">            objectOutputStream.writeObject(message);</span><br><span class="line">            log.info(<span class="string">&quot;client send message: &quot;</span> + message.getConnect());</span><br><span class="line">            <span class="comment">// 通过输入流获取服务器响应信息</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(socket.getInputStream());</span><br><span class="line">            <span class="keyword">return</span> objectInputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;occur exception:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HelloClient</span> <span class="variable">helloClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloClient</span>();</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) helloClient.send(<span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;hello&quot;</span>), <span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;client receive message：&quot;</span> + message.getConnect());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>因为<code>ServerSocket</code>的<code>accept</code>方法是阻塞方法</p>
<p>服务端同一时间只能处理一个客户端</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>1、为每个请求的客户端创建一个线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="type">HelloClient</span> <span class="variable">helloClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloClient</span>();</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) helloClient.send(<span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;helloA&quot;</span>), <span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;client receive message：&quot;</span> + message.getConnect());</span><br><span class="line">&#125;);</span><br><span class="line">threadA.start();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="type">HelloClient</span> <span class="variable">helloClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloClient</span>();</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) helloClient.send(<span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;helloB&quot;</span>), <span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;client receive message：&quot;</span> + message.getConnect());</span><br><span class="line">&#125;);</span><br><span class="line">threadB.start();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="type">HelloClient</span> <span class="variable">helloClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloClient</span>();</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) helloClient.send(<span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;helloC&quot;</span>), <span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;client receive message：&quot;</span> + message.getConnect());</span><br><span class="line">&#125;);</span><br><span class="line">threadC.start();</span><br></pre></td></tr></table></figure>

<p>频繁创建线程、销毁线程是非常浪费资源的，线程池是线程管理的最佳选择</p>
<p>2、使用线程池处理客户端请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> Executors.defaultThreadFactory();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">100</span>, <span class="number">1</span>, TimeUnit.MINUTES, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">100</span>), threadFactory);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">    threadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="type">HelloClient</span> <span class="variable">helloClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloClient</span>();</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) helloClient.send(<span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;hello&quot;</span> + finalI), <span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;client receive message：&quot;</span> + message.getConnect());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个核心线程<code>10</code>、最大线程<code>100</code>，非核心且空闲线程的最长存活时间为<code>1 min</code>、有界工作队列容量为<code>100</code>、使用默认线程工厂的线程池</p>
<p>虽然在创建线程上节约了时间，但是依然提升优先，瓶颈在于<code>IO</code>模型是同步阻塞<code>IO</code>，要想有质的提升需要使用别的<code>IO</code>模型，如同步非阻塞<code>IO</code>，多路复用<code>IO</code>，异步<code>IO</code>等。<code>Netty</code>是基于同步非阻塞<code>IO</code>模型的一个网络编程框架，使用非常方便。</p>
]]></content>
      <categories>
        <category>socket</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>网络通信</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-IOC</title>
    <url>/2023/04/28/Spring-IOC/</url>
    <content><![CDATA[<h3 id="SpringIOC的概念"><a href="#SpringIOC的概念" class="headerlink" title="SpringIOC的概念"></a>SpringIOC的概念</h3><p>IOC是控制反转，就是由容器来负责管理对象的生命周期和对象间的关系。</p>
<h3 id="SpringIOC的意义"><a href="#SpringIOC的意义" class="headerlink" title="SpringIOC的意义"></a>SpringIOC的意义</h3><p>在传统的应用程序中，对象的创建和依赖关系的管理通常由开发人员手动进行。这种紧密耦合的设计使得程序难以测试、理解和修改。SpringIOC通过反转对象的控制，将对象的创建和依赖关系的管理交给容器负，从而实现了对象之间的松耦合。</p>
<h3 id="SpringIOC的实现机制"><a href="#SpringIOC的实现机制" class="headerlink" title="SpringIOC的实现机制"></a>SpringIOC的实现机制</h3><h3 id="IOC和DI的区别"><a href="#IOC和DI的区别" class="headerlink" title="IOC和DI的区别"></a>IOC和DI的区别</h3>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBean的生命周期</title>
    <url>/2023/05/09/SpringBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SpringBoot自动装配原理</title>
    <url>/2023/05/06/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spring常见的注解</title>
    <url>/2023/05/06/Spring%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spring中的设计模式</title>
    <url>/2023/05/06/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spring和SpringBoot的区别</title>
    <url>/2023/04/30/Spring%E5%92%8CSpringBoot%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>TCP与UDP</title>
    <url>/2023/05/05/TCP%E4%B8%8EUDP/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/2023/05/06/ThreadLocal/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/09/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode第331场周赛</title>
    <url>/2022/09/19/leetcode%E7%AC%AC311%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="最小偶倍数"><a href="#最小偶倍数" class="headerlink" title="最小偶倍数"></a>最小偶倍数</h2><p>给你一个正整数 <code>n</code> ，返回 <code>2</code> 和 <code>n</code> 的最小公倍数（正整数）。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：n &#x3D; 5<br>输出：10<br>解释：5 和 2 的最小公倍数是 10 。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：n &#x3D; 6<br>输出：6<br>解释：6 和 2 的最小公倍数是 6 。注意数字会是它自身的倍数。</p>
</blockquote>
<p>提示</p>
<blockquote>
<p>1 &lt;&#x3D; n &lt;&#x3D; 150</p>
</blockquote>
<p>直接gcd就可以，但是有一个数是2是确定的，这个2比较特殊。所以有另一种写法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y == <span class="number">0</span> ? x : <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestEvenMultiple</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="number">2</span> / <span class="built_in">gcd</span>(<span class="number">2</span>, n); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestEvenMultiple</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span>) <span class="keyword">return</span> n * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="最长的字母序连续字符串的长度"><a href="#最长的字母序连续字符串的长度" class="headerlink" title="最长的字母序连续字符串的长度"></a>最长的字母序连续字符串的长度</h2><p><strong>字母序连续字符串</strong> 是由字母表中连续字母组成的字符串。换句话说，字符串</p>
<blockquote>
<p>“abcdefghijklmnopqrstuvwxyz”</p>
</blockquote>
<p>的任意字符串都是<strong>字母序连续字符串</strong> 。</p>
<ul>
<li>例如，”abc” 是一个字母序连续字符串，而 “acb” 和 “za” 不是。</li>
<li>给你一个仅由小写英文字母组成的字符串 s ，返回其 最长 的 字母序连续子字符串 的长度。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：s &#x3D; “abacaba”<br>输出：2<br>解释：共有 4 个不同的字母序连续子字符串 “a”、”b”、”c” 和 “ab” 。<br>“ab” 是最长的字母序连续子字符串。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：s &#x3D; “abcde”<br>输出：5<br>解释：”abcde” 是最长的字母序连续子字符串。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<p>直接比较一下就行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestContinuousSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mxlen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] - s[i - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                mxlen++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, mxlen);</span><br><span class="line">                mxlen = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ans, mxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="翻转二叉树的奇数层"><a href="#翻转二叉树的奇数层" class="headerlink" title="翻转二叉树的奇数层"></a>翻转二叉树的奇数层</h2><p>给你一棵<strong>完美</strong>二叉树的根节点 root ，请你反转这棵树中每个<strong>奇数</strong>层的节点值。</p>
<ul>
<li>例如，假设第 3 层的节点值是 [2,1,3,4,7,11,29,18] ，那么反转后它应该变成 [18,29,11,7,4,3,1,2] 。<br>  反转后，返回树的根节点。</li>
</ul>
<p><strong>完美</strong>二叉树需满足：二叉树的所有父节点都有两个子节点，且所有叶子节点都在同一层。</p>
<p>节点的<strong>层数</strong>等于该节点到根节点之间的边数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/07/28/first_case1.png" alt="img"></p>
<blockquote>
<p>输入：root &#x3D; [2,3,5,8,13,21,34]<br>输出：[2,5,3,8,13,21,34]<br>解释：<br>这棵树只有一个奇数层。<br>在第 1 层的节点分别是 3、5 ，反转后为 5、3 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/07/28/second_case3.png" alt="img"></p>
<blockquote>
<p>输入：root &#x3D; [7,13,11]<br>输出：[7,11,13]<br>解释：<br>在第 1 层的节点分别是 13、11 ，反转后为 11、13 。 </p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数目在范围 <code>[1, 214]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 105</code></li>
<li><code>root</code> 是一棵 <strong>完美</strong> 二叉树</li>
</ul>
<p><strong>DFS</strong>，搜的时候把当前深度传进去，如果当前深度是基数，交换两个节点的val。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* left, TreeNode* right, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!left) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(d % <span class="number">2</span>) <span class="built_in">swap</span>(left-&gt;val, right-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(left-&gt;left, right-&gt;right, d + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(left-&gt;right, right-&gt;left, d + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reverseOddLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, root-&gt;right, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="字符串的前缀分数和"><a href="#字符串的前缀分数和" class="headerlink" title="字符串的前缀分数和"></a>字符串的前缀分数和</h2><p>给你一个长度为 n 的数组 words ，该数组由<strong>非空</strong>字符串组成。</p>
<p>定义字符串 word 的<strong>分数</strong>等于以 word 作为 前缀 的 words[i] 的数目。</p>
<ul>
<li>例如，如果 words &#x3D; [“a”, “ab”, “abc”, “cab”] ，那么 “ab” 的分数是 2 ，因为 “ab” 是 “ab” 和 “abc” 的一个前缀。</li>
</ul>
<p>返回一个长度为 n 的数组 answer ，其中 answer[i] 是 words[i] 的每个非空前缀的分数 总和 。</p>
<p><strong>注意</strong>：字符串视作它自身的一个前缀。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：words &#x3D; [“abc”,”ab”,”bc”,”b”]<br>输出：[5,4,3,2]<br>解释：对应每个字符串的答案如下：</p>
<p>“abc” 有 3 个前缀：”a”、”ab” 和 “abc” 。</p>
<p>2 个字符串的前缀为 “a” ，2 个字符串的前缀为 “ab” ，1 个字符串的前缀为 “abc” 。<br>总计 answer[0] &#x3D; 2 + 2 + 1 &#x3D; 5 。</p>
<p>“ab” 有 2 个前缀：”a” 和 “ab” 。</p>
<p>2 个字符串的前缀为 “a” ，2 个字符串的前缀为 “ab” 。<br>总计 answer[1] &#x3D; 2 + 2 &#x3D; 4 。</p>
<p>“bc” 有 2 个前缀：”b” 和 “bc” 。</p>
<p>2 个字符串的前缀为 “b” ，1 个字符串的前缀为 “bc” 。<br>总计 answer[2] &#x3D; 2 + 1 &#x3D; 3 。</p>
<p>“b” 有 1 个前缀：”b”。</p>
<p>2 个字符串的前缀为 “b” 。<br>总计 answer[3] &#x3D; 2 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：words &#x3D; [“abcd”]<br>输出：[4]<br>解释：<br>“abcd” 有 4 个前缀 “a”、”ab”、”abc” 和 “abcd”。<br>每个前缀的分数都是 1 ，总计 answer[0] &#x3D; 1 + 1 + 1 + 1 &#x3D; 4 。</p>
</blockquote>
<p>建<strong>Trie</strong>，统计。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> tr[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; word)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> u = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!tr[p][u]) &#123;</span><br><span class="line">                tr[p][u] = ++idx;</span><br><span class="line">            &#125;</span><br><span class="line">            p = tr[p][u];</span><br><span class="line">            cnt[p]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string&amp; word)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> u = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            p = tr[p][u];</span><br><span class="line">            res += cnt[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sumPrefixScores</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(tr, <span class="number">0</span> , <span class="keyword">sizeof</span> tr);</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        <span class="keyword">for</span>(string&amp; word : words) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(string&amp; word : words) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">query</span>(word));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Trie</tag>
        <tag>Binary tree</tag>
        <tag>Number Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode第319场周赛</title>
    <url>/2022/11/16/leetcode%E7%AC%AC319%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h3 id="温度转换"><a href="#温度转换" class="headerlink" title="温度转换"></a>温度转换</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给你一个四舍五入到两位小数的非负浮点数$$celsius$$来表示温度，以 <strong>摄氏度</strong>（<strong>Celsius</strong>）为单位。</p>
<p>你需要将摄氏度转换为 <strong>开氏度</strong>（<strong>Kelvin</strong>）和 <strong>华氏度</strong>（<strong>Fahrenheit</strong>），并以数组 $$ans &#x3D; [kelvin, fahrenheit]$$的形式返回结果。</p>
<p>返回数组 $$ans$$ 。与实际答案误差不超过 $$10^{-5}$$ 的会视为正确答案。</p>
<p><strong>注意：</strong></p>
<ul>
<li><code>开氏度 = 摄氏度 + 273.15</code></li>
<li><code>华氏度 = 摄氏度 * 1.80 + 32.00</code></li>
</ul>
<p><strong>示例 1 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：celsius = 36.50</span><br><span class="line">输出：[309.65000,97.70000]</span><br><span class="line">解释：36.50 摄氏度：转换为开氏度是 309.65 ，转换为华氏度是 97.70 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：celsius = 122.11</span><br><span class="line">输出：[395.26000,251.79800]</span><br><span class="line">解释：122.11 摄氏度：转换为开氏度是 395.26 ，转换为华氏度是 251.798 。</span><br></pre></td></tr></table></figure>

<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>模拟即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">convertTemperature</span><span class="params">(<span class="type">double</span> celsius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;celsius + <span class="number">273.15</span>, celsius * <span class="number">1.80</span> + <span class="number">32.00</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="最小公倍数为K的子数组数目"><a href="#最小公倍数为K的子数组数目" class="headerlink" title="最小公倍数为K的子数组数目"></a>最小公倍数为K的子数组数目</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <code>nums</code> 的 <strong>子数组</strong> 中满足 <em>元素最小公倍数为 <code>k</code></em> 的子数组数目。</p>
<p><strong>子数组</strong> 是数组中一个连续非空的元素序列。</p>
<p><strong>数组的最小公倍数</strong> 是可被所有数组元素整除的最小正整数。</p>
<p><strong>示例 1 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,6,2,7,1], k = 6</span><br><span class="line">输出：4</span><br><span class="line">解释：以 6 为最小公倍数的子数组是：</span><br><span class="line">- [3,6,2,7,1]</span><br><span class="line">- [3,6,2,7,1]</span><br><span class="line">- [3,6,2,7,1]</span><br><span class="line">- [3,6,2,7,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3], k = 2</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在以 2 为最小公倍数的子数组。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i], k &lt;= 1000</code></li>
</ul>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>$$nums[i]$$, $$nums[i + 1]$$, $$nums[i + 2]$$的最小公倍数等于$$(nums[i]与nums[i + 1])$$的最小公倍数与$$nums[i + 2]$$的最小公倍数，是一个传导的过程，若干数的最大公约数也是如此。</p>
<p>当最小公倍数大于$$k$$时，及时break，减少不必要的计算。</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarrayLCM</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> t = nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                t = t * nums[j] / <span class="built_in">gcd</span>(t, nums[j]);</span><br><span class="line">                <span class="keyword">if</span>(t == k) res++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(t &gt; k) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="逐层排序二叉树所需的最小操作数目"><a href="#逐层排序二叉树所需的最小操作数目" class="headerlink" title="逐层排序二叉树所需的最小操作数目"></a>逐层排序二叉树所需的最小操作数目</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>给你一个 <strong>值互不相同</strong> 的二叉树的根节点 <code>root</code> 。</p>
<p>在一步操作中，你可以选择 <strong>同一层</strong> 上任意两个节点，交换这两个节点的值。</p>
<p>返回每一层按 <strong>严格递增顺序</strong> 排序所需的最少操作数目。</p>
<p>节点的 <strong>层数</strong> 是该节点和根节点之间的路径的边数。</p>
<p><strong>示例 1 ：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/09/18/image-20220918174006-2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">- 交换 4 和 3 。第 2 层变为 [3,4] 。</span><br><span class="line">- 交换 7 和 5 。第 3 层变为 [5,6,8,7] 。</span><br><span class="line">- 交换 8 和 7 。第 3 层变为 [5,6,7,8] 。</span><br><span class="line">共计用了 3 步操作，所以返回 3 。</span><br><span class="line">可以证明 3 是需要的最少操作数目。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 ：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/09/18/image-20220918174026-3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,3,2,7,6,5,4]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">- 交换 3 和 2 。第 2 层变为 [2,3] 。 </span><br><span class="line">- 交换 7 和 4 。第 3 层变为 [4,6,5,7] 。 </span><br><span class="line">- 交换 6 和 5 。第 3 层变为 [4,5,6,7] 。</span><br><span class="line">共计用了 3 步操作，所以返回 3 。 </span><br><span class="line">可以证明 3 是需要的最少操作数目。</span><br></pre></td></tr></table></figure>

<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>此问题可以拆解成两个问题。第一个问题是二叉树的层序遍历，第二个问题是如何在交换次数尽量少的情况下使得数组有序。</p>
<p>层序遍历可以用$BFS$来实现。</p>
<p>第二个问题可以通过</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4>]]></content>
  </entry>
  <entry>
    <title>第313场周赛</title>
    <url>/2022/10/02/leetcode%E7%AC%AC313%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="公因子的数目"><a href="#公因子的数目" class="headerlink" title="公因子的数目"></a><a href="https://leetcode.cn/problems/number-of-common-factors/">公因子的数目</a></h2><p>给你两个正整数 <code>a</code> 和 <code>b</code> ，返回 <code>a</code> 和 <code>b</code> 的 <strong>公</strong> 因子的数目。</p>
<p>如果 <code>x</code> 可以同时整除 <code>a</code> 和 <code>b</code> ，则认为 <code>x</code> 是 <code>a</code> 和 <code>b</code> 的一个 <strong>公因子</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：a = 12, b = 6</span><br><span class="line">输出：4</span><br><span class="line">解释：12 和 6 的公因子是 1、2、3、6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：a = 25, b = 30</span><br><span class="line">输出：2</span><br><span class="line">解释：25 和 30 的公因子是 1、5 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= a, b &lt;= 1000</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">commonFactors</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a % i == <span class="number">0</span> &amp;&amp; b % i == <span class="number">0</span>) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="沙漏的最大总和"><a href="#沙漏的最大总和" class="headerlink" title="沙漏的最大总和"></a><a href="https://leetcode.cn/problems/maximum-sum-of-an-hourglass/">沙漏的最大总和</a></h2><p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>grid</code> 。</p>
<p>按以下形式将矩阵的一部分定义为一个 <strong>沙漏</strong> ：</p>
<p><img src="https://assets.leetcode.com/uploads/2022/08/21/img.jpg" alt="img"></p>
<p>返回沙漏中元素的 <strong>最大</strong> 总和。</p>
<p><strong>注意：</strong>沙漏无法旋转且必须整个包含在矩阵中。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/08/21/1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]</span><br><span class="line">输出：30</span><br><span class="line">解释：上图中的单元格表示元素总和最大的沙漏：6 + 2 + 1 + 2 + 9 + 2 + 8 = 30 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/08/21/2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：35</span><br><span class="line">解释：上图中的单元格表示元素总和最大的沙漏：1 + 2 + 3 + 5 + 7 + 8 + 9 = 35 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>3 &lt;= m, n &lt;= 150</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 106</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; m - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> s = grid[i][j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j - <span class="number">1</span>; k &lt; j - <span class="number">1</span> + <span class="number">3</span>; k++) &#123;</span><br><span class="line">                    s += grid[i - <span class="number">1</span>][k] + grid[i + <span class="number">1</span>][k];</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="最小-XOR"><a href="#最小-XOR" class="headerlink" title="最小 XOR"></a><a href="https://leetcode.cn/problems/minimize-xor/">最小 XOR</a></h2><p>给你两个正整数 <code>num1</code> 和 <code>num2</code> ，找出满足下述条件的整数 <code>x</code> ：</p>
<ul>
<li><code>x</code> 的置位数和 <code>num2</code> 相同，且</li>
<li><code>x XOR num1</code> 的值 <strong>最小</strong></li>
</ul>
<p>注意 <code>XOR</code> 是按位异或运算。</p>
<p>返回整数 <code>x</code> 。题目保证，对于生成的测试用例， <code>x</code> 是 <strong>唯一确定</strong> 的。</p>
<p>整数的 <strong>置位数</strong> 是其二进制表示中 <code>1</code> 的数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num1 = 3, num2 = 5</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">num1 和 num2 的二进制表示分别是 0011 和 0101 。</span><br><span class="line">整数 3 的置位数与 num2 相同，且 3 XOR 3 = 0 是最小的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num1 = 1, num2 = 12</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">num1 和 num2 的二进制表示分别是 0001 和 1100 。</span><br><span class="line">整数 3 的置位数与 num2 相同，且 3 XOR 1 = 2 是最小的。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num1, num2 &lt;= 109</code></li>
</ul>
<p>位运算，<code>^</code>运算相同为0，不同为1，要让最终的<code>^</code>结果最小，用尽量多的<code>1</code>从高位开始去占高位的<code>1</code>，这样会抹掉高位的<code>1</code>，如果还有多余的<code>1</code>，那就从低位开始，占低位的<code>0</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimizeXor</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num2 &amp; <span class="number">1</span>) cnt++;</span><br><span class="line">            num2 &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span> &amp;&amp; cnt &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num1 &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span> &amp;&amp; cnt &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(num1 &gt;&gt; i &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="对字母串可执行的最大删除数"><a href="#对字母串可执行的最大删除数" class="headerlink" title="对字母串可执行的最大删除数"></a>对字母串可执行的最大删除数</h2><p>给你一个仅由小写英文字母组成的字符串 <code>s</code> 。在一步操作中，你可以：</p>
<ul>
<li>删除 <strong>整个字符串</strong> <code>s</code> ，或者</li>
<li>对于满足 <code>1 &lt;= i &lt;= s.length / 2</code> 的任意 <code>i</code> ，如果 <code>s</code> 中的 <strong>前</strong> <code>i</code> 个字母和接下来的 <code>i</code> 个字母 <strong>相等</strong> ，删除 <strong>前</strong> <code>i</code> 个字母。</li>
</ul>
<p>例如，如果 <code>s = &quot;ababc&quot;</code> ，那么在一步操作中，你可以删除 <code>s</code> 的前两个字母得到 <code>&quot;abc&quot;</code> ，因为 <code>s</code> 的前两个字母和接下来的两个字母都等于 <code>&quot;ab&quot;</code> 。</p>
<p>返回删除 <code>s</code> 所需的最大操作数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcabcdabc&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">- 删除前 3 个字母（&quot;abc&quot;），因为它们和接下来 3 个字母相等。现在，s = &quot;abcdabc&quot;。</span><br><span class="line">- 删除全部字母。</span><br><span class="line">一共用了 2 步操作，所以返回 2 。可以证明 2 是所需的最大操作数。</span><br><span class="line">注意，在第二步操作中无法再次删除 &quot;abc&quot; ，因为 &quot;abc&quot; 的下一次出现并不是位于接下来的 3 个字母。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aaabaab&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">- 删除第一个字母（&quot;a&quot;），因为它和接下来的字母相等。现在，s = &quot;aabaab&quot;。</span><br><span class="line">- 删除前 3 个字母（&quot;aab&quot;），因为它们和接下来 3 个字母相等。现在，s = &quot;aab&quot;。 </span><br><span class="line">- 删除第一个字母（&quot;a&quot;），因为它和接下来的字母相等。现在，s = &quot;ab&quot;。</span><br><span class="line">- 删除全部字母。</span><br><span class="line">一共用了 4 步操作，所以返回 4 。可以证明 4 是所需的最大操作数。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aaaaa&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：在每一步操作中，都可以仅删除 s 的第一个字母。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 4000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<p>字符串哈希，线性动态规划。</p>
<p>用字符串<code>hash</code>通过<code>O(n^2)</code>的预处理，可以在<code>O(1)</code>的时间内查询两个字符串是否相同。</p>
<p><code>f[i]</code>表示删掉<code>i</code>后缀用的最大操作次数。</p>
<p>枚举后缀长度<code>j</code>，如果<code>i</code>开始长度为<code>j</code>的字符串可以删除，</p>
<p>表示<code>[i, i + j - 1]</code>和<code>[i + j, i + j + j -1]</code>的字符串是相同的，</p>
<p>那么后缀<code>i</code>的删除次数可以增加一次，可以更新最大删除次数：<code>f[i] = max(f[i], f[i + j] + 1)</code>，</p>
<p>对每一个<code>i</code>枚举所有合法的长度<code>j</code>，取最大值，便是<code>f[i]</code>，删除<code>i</code>后缀的最大操作次数。</p>
<p>时间复杂度为<code>O(n^2)</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> P = <span class="number">131</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> h[<span class="number">4005</span>], p[<span class="number">4005</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">            h[i] = h[i - <span class="number">1</span>] * P + s[i - <span class="number">1</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            f[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= (n - i + <span class="number">1</span>) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">get</span>(i, i + j - <span class="number">1</span>) == <span class="built_in">get</span>(i + j, i + j + j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    f[i] = <span class="built_in">max</span>(f[i], f[i + j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">1</span>];    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>leetcode第87场双周赛</title>
    <url>/2022/09/22/leetcode%E7%AC%AC87%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="共同度过的日子"><a href="#共同度过的日子" class="headerlink" title="共同度过的日子"></a>共同度过的日子</h2><p>Alice 和 Bob 计划分别去罗马开会。</p>
<p>给你四个字符串 arriveAlice ，leaveAlice ，arriveBob 和 leaveBob 。Alice 会在日期 arriveAlice 到 leaveAlice 之间在城市里（日期为闭区间），而 Bob 在日期 arriveBob 到 leaveBob 之间在城市里（日期为闭区间）。每个字符串都包含 5 个字符，格式为 “MM-DD” ，对应着一个日期的月和日。</p>
<p>请你返回 Alice和 Bob 同时在罗马的天数。</p>
<p>你可以假设所有日期都在 同一个 自然年，而且 不是 闰年。每个月份的天数分别为：[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] 。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：arriveAlice &#x3D; “08-15”, leaveAlice &#x3D; “08-18”, arriveBob &#x3D; “08-16”, leaveBob &#x3D; “08-19”<br>输出：3<br>解释：Alice 从 8 月 15 号到 8 月 18 号在罗马。Bob 从 8 月 16 号到 8 月 19 号在罗马，他们同时在罗马的日期为 8 月 16、17 和 18 号。所以答案为 3 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：arriveAlice &#x3D; “10-01”, leaveAlice &#x3D; “10-31”, arriveBob &#x3D; “11-01”, leaveBob &#x3D; “12-31”<br>输出：0<br>解释：Alice 和 Bob 没有同时在罗马的日子，所以我们返回 0 。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>所有日期的格式均为 “MM-DD” 。</li>
<li>Alice 和 Bob 的到达日期都 早于或等于 他们的离开日期。</li>
<li>题目测试用例所给出的日期均为 非闰年 的有效日期。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> months[<span class="number">13</span>] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">days</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> month, day;</span><br><span class="line">        <span class="built_in">sscanf</span>(s.<span class="built_in">c_str</span>(), <span class="string">&quot;%d-%d&quot;</span>, &amp;month, &amp;day);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; month; i++) &#123;</span><br><span class="line">            sum += months[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sum += day;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDaysTogether</span><span class="params">(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(<span class="built_in">days</span>(leaveAlice), <span class="built_in">days</span>(leaveBob)) - <span class="built_in">max</span>(<span class="built_in">days</span>(arriveAlice), <span class="built_in">days</span>(arriveBob)) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="运动员和训练师的最大匹配数"><a href="#运动员和训练师的最大匹配数" class="headerlink" title="运动员和训练师的最大匹配数"></a>运动员和训练师的最大匹配数</h2><p>给你一个下标从 0 开始的整数数组 players ，其中 players[i] 表示第 i 名运动员的 能力 值，同时给你一个下标从 0 开始的整数数组 trainers ，其中 trainers[j] 表示第 j 名训练师的 训练能力值 。</p>
<p>如果第 i 名运动员的能力值 小于等于 第 j 名训练师的能力值，那么第 i 名运动员可以 匹配 第 j 名训练师。除此以外，每名运动员至多可以匹配一位训练师，每位训练师最多可以匹配一位运动员。</p>
<p>请你返回满足上述要求 players 和 trainers 的 最大 匹配数。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：players &#x3D; [4,7,9], trainers &#x3D; [8,2,5,8]<br>输出：2<br>解释：<br>得到两个匹配的一种方案是：</p>
<p>players[0] 与 trainers[0] 匹配，因为 4 &lt;&#x3D; 8 。</p>
<p>players[1] 与 trainers[3] 匹配，因为 7 &lt;&#x3D; 8 。<br>可以证明 2 是可以形成的最大匹配数。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：players &#x3D; [1,1,1], trainers &#x3D; [10]<br>输出：1<br>解释：<br>训练师可以匹配所有 3 个运动员<br>每个运动员至多只能匹配一个训练师，所以最大答案是 1 。</p>
</blockquote>
<p>提示：</p>
<ul>
<li><code>1 &lt;= players.length, trainers.length &lt;= 105</code></li>
<li><code>1 &lt;= players[i], trainers[j] &lt;= 109</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">matchPlayersAndTrainers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; players, vector&lt;<span class="type">int</span>&gt;&amp; trainers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(players.<span class="built_in">begin</span>(), players.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(trainers.<span class="built_in">begin</span>(), trainers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; players.<span class="built_in">size</span>() &amp;&amp; j &lt; trainers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; trainers.<span class="built_in">size</span>() &amp;&amp; players[i] &gt; trainers[j]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; trainers.<span class="built_in">size</span>() &amp;&amp; trainers[j] &gt;= trainers[i]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="按位或最大的最小子数组长度"><a href="#按位或最大的最小子数组长度" class="headerlink" title="按位或最大的最小子数组长度"></a>按位或最大的最小子数组长度</h2><p>给你一个长度为 n 下标从 0 开始的数组 nums ，数组中所有数字均为非负整数。对于 0 到 n - 1 之间的每一个下标 i ，你需要找出 nums 中一个 最小 非空子数组，它的起始位置为 i （包含这个位置），同时有 最大 的 按位或运算值 。</p>
<ul>
<li>换言之，令 Bij 表示子数组 nums[i…j] 的按位或运算的结果，你需要找到一个起始位置为 i 的最小子数组，这个子数组的按位或运算的结果等于 max(Bik) ，其中 i &lt;&#x3D; k &lt;&#x3D; n - 1 。<br>  一个数组的按位或运算值是这个数组里所有数字按位或运算的结果。</li>
</ul>
<p>请你返回一个大小为 n 的整数数组 answer，其中 answer[i]是开始位置为 i ，按位或运算结果最大，且 最短 子数组的长度。</p>
<p>子数组 是数组里一段连续非空元素组成的序列。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：nums &#x3D; [1,0,2,1,3]<br>输出：[3,3,2,2,1]<br>解释：<br>任何位置开始，最大按位或运算的结果都是 3 。</p>
<ul>
<li>下标 0 处，能得到结果 3 的最短子数组是 [1,0,2] 。</li>
<li>下标 1 处，能得到结果 3 的最短子数组是 [0,2,1] 。</li>
<li>下标 2 处，能得到结果 3 的最短子数组是 [2,1] 。</li>
<li>下标 3 处，能得到结果 3 的最短子数组是 [1,3] 。</li>
<li>下标 4 处，能得到结果 3 的最短子数组是 [3] 。<br>所以我们返回 [3,3,2,2,1] 。</li>
</ul>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：nums &#x3D; [1,2]<br>输出：[2,1]<br>解释：<br>下标 0 处，能得到最大按位或运算值的最短子数组长度为 2 。<br>下标 1 处，能得到最大按位或运算值的最短子数组长度为 1 。<br>所以我们返回 [2,1] 。</p>
</blockquote>
<p><strong>题解：</strong></p>
<p>逆序遍历，因为是要求最短，所以记录每一位的<code>1</code>第一次出现的位置，又因为要求或运算最大，所以还需要对每一位<code>1</code></p>
<p>第一次出现的位置取最大值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">smallestSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">30</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> index = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">30</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt;&gt; j &amp; <span class="number">1</span>) a[j] = i;</span><br><span class="line">                index = <span class="built_in">max</span>(index, a[j]);</span><br><span class="line">            &#125;      </span><br><span class="line">            res[i] = index - i + <span class="number">1</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="完成所有交易的初始最少钱数"><a href="#完成所有交易的初始最少钱数" class="headerlink" title="完成所有交易的初始最少钱数"></a>完成所有交易的初始最少钱数</h2><p>给你一个下标从 0 开始的二维整数数组 transactions，其中transactions[i] &#x3D; [costi, cashbacki] 。</p>
<p>数组描述了若干笔交易。其中每笔交易必须以 某种顺序 恰好完成一次。在任意一个时刻，你有一定数目的钱 money ，为了完成交易 i ，money &gt;&#x3D; costi 这个条件必须为真。执行交易后，你的钱数 money 变成 money - costi + cashbacki 。</p>
<p>请你返回 任意一种 交易顺序下，你都能完成所有交易的最少钱数 money 是多少。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：transactions &#x3D; [[2,1],[5,0],[4,2]]<br>输出：10<br>解释：<br>刚开始 money &#x3D; 10 ，交易可以以任意顺序进行。<br>可以证明如果 money &lt; 10 ，那么某些交易无法进行。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：transactions &#x3D; [[3,0],[0,3]]<br>输出：3<br>解释：</p>
<ul>
<li>如果交易执行的顺序是 [[3,0],[0,3]] ，完成所有交易需要的最少钱数是 3 。</li>
<li>如果交易执行的顺序是 [[0,3],[3,0]] ，完成所有交易需要的最少钱数是 0 。<br>所以，刚开始钱数为 3 ，任意顺序下交易都可以全部完成。</li>
</ul>
</blockquote>
<p><strong>题解：</strong></p>
<p>下一笔交易能够进行一定满足条件</p>
<blockquote>
<p>money - (cost_1 - back_1) + (cost_2 - back_2) … &gt;&#x3D; cost_i</p>
<p>那么money &gt;&#x3D;   (cost_1 - back_1) + (cost_2 - back_2) + cost_i</p>
<p>最少钱数money等于右侧最大值，右侧表示按照某种顺序，进行第i笔交易时，达到了最大钱数。</p>
<p>右侧由两部分组成， (cost_1 - back_1) + (cost_2 - back_2) 和 cost_i</p>
<p>要整体达到最大值，所以这两部分也需要达到最大值。</p>
<p>第一部分，统计所有cost  &gt; back 和合。</p>
<p>第二部分，我们无法直接得出cost_i在哪笔交易中，但是我们可以通过枚举所有交易。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minimumMoney</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; transactions)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : transactions) &#123;</span><br><span class="line">            <span class="type">int</span> cost = p[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> cashback = p[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(cost &gt; cashback) &#123;</span><br><span class="line">                sum += cost - cashback;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : transactions) &#123;</span><br><span class="line">            <span class="type">int</span> cost = p[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> cashback = p[<span class="number">1</span>];</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> s = sum;</span><br><span class="line">            <span class="keyword">if</span>(cost &gt; cashback) &#123;</span><br><span class="line">                s -= cost - cashback;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, s + cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>linux软链接和硬链接</title>
    <url>/2023/05/06/linux%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>ping的工作原理</title>
    <url>/2023/05/01/ping%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>redis主从复制</title>
    <url>/2023/04/30/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>redis哨兵</title>
    <url>/2023/04/30/redis%E5%93%A8%E5%85%B5/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>redis内存淘汰策略</title>
    <url>/2023/04/30/redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>redis持久化机制</title>
    <url>/2023/04/29/redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>redis数据结构</title>
    <url>/2023/04/28/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>redis的AOF、RDB</title>
    <url>/2023/04/30/redis%E7%9A%84AOF%E3%80%81RDB/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>缓存雪崩、缓存击穿、缓存穿透</title>
    <url>/2023/04/30/redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>redis过期删除策略</title>
    <url>/2023/04/30/redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>一致性哈希算法</title>
    <url>/2023/04/25/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>中国银联专场竞赛（2023届校园招聘专场）</title>
    <url>/2022/10/02/%E4%B8%AD%E5%9B%BD%E9%93%B6%E8%81%94%E4%B8%93%E5%9C%BA%E7%AB%9E%E8%B5%9B%EF%BC%882023%E5%B1%8A%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E4%B8%93%E5%9C%BA%EF%BC%89/</url>
    <content><![CDATA[<h2 id="重构链表"><a href="#重构链表" class="headerlink" title="重构链表"></a>重构链表</h2><p>给定一个链表的头节点 <code>head</code> ，在不改变节点顺序的基础下，请删除链表中所有值为 <code>偶数</code> 的节点，并返回这个链表 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>若链表为空，则返回空值。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<code>head = [1,4,3,6]</code></p>
<p>输出：<code>[1,3]</code></p>
<p>解释：如下图所示，黑色节点的值均为偶数，删除这些节点后，链表为 <code>[1,3]</code><br><img src="https://pic.leetcode-cn.com/1663123060-ffBMiH-image.png" alt="image.png"></p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<code>head = [5,7,9,9,1]</code></p>
<p>输出：<code>[5,7,9,9,1]</code></p>
<p>解释：原链表中不存在值为偶数的节点。</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入：<code>head = [2,4]</code></p>
<p>输出：<code>[]</code></p>
<p>解释：原链表中所有节点值均为偶数。</p>
</blockquote>
<p><strong>提示：</strong><br><code>1 &lt;= head.length &lt;= 10^5</code><br><code>0 &lt;= Node.val &lt;= 100</code></p>
<p>创建虚拟头节点，然后遍历链表，用cur指针去更新虚拟节点的后继。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reContruct</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(head -&gt; val % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                head = head -&gt; next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur -&gt; next = head;</span><br><span class="line">            head = head -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="勘探补给"><a href="#勘探补给" class="headerlink" title="勘探补给"></a>勘探补给</h2><p>工程部在一条坐标轴上设立了若干补给站，<code>station[i]</code> 表示编号为 <code>i</code> 的补给站的坐标。</p>
<p>现在有一些正在执行任务的勘探队需要进行补给，<code>pos[i]</code> 表示第 <code>i</code> 个勘探队当前所在位置的坐标。勘探队将优先选择<strong>当前距离最近</strong>的补给站进行补给。若两座补给站距离相同，则选择坐标更小的那一个。</p>
<p><strong>请按顺序</strong>返回这些勘探队所选择的补给站编号。</p>
<p><strong>注意：</strong></p>
<ul>
<li><code>station</code> 中的元素严格递增，即 <code>station[i] &lt; station[i+1]</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<br><code>station = [2,7,8,10]</code><br><code>pos = [4,9]</code><br>输出：<br><code>[0,2]</code><br>解释：<br>坐标 <code>4</code> 的勘探队与坐标为 <code>2</code> 和 <code>7</code> 的补给站距离分别为 <code>2</code> 和 <code>3</code>， 选择坐标为 <code>2</code>的补给站<br>坐标 <code>9</code> 的勘探队与坐标为 <code>8</code> 和 <code>10</code> 的补给站的距离均为 <code>1</code>， 选择坐标更小为 <code>8</code> 的补给站<br>返回编号为 <code>[0,2]</code> 的补给站。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<br><code>station = [2,5,8,14,17]</code><br><code>pos = [1,14,11,2]</code><br>输出：<br><code>[0,3,2,0]</code></p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= pos.length,station.length &lt;= 10^4</code></li>
<li><code>1 &lt;= pos[i] &lt;= 10^6</code></li>
<li><code>1 &lt;= station[i] &lt; station[i+1] &lt;= 10^6</code></li>
</ul>
<p>模拟即可，寻找的时候用二分即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">explorationSupply</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; station, vector&lt;<span class="type">int</span>&gt;&amp; pos)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = pos.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(station.<span class="built_in">begin</span>(), station.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> front = <span class="built_in">lower_bound</span>(station.<span class="built_in">begin</span>(), station.<span class="built_in">end</span>(), pos[i]) - station.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> back = <span class="built_in">upper_bound</span>(station.<span class="built_in">begin</span>(), station.<span class="built_in">end</span>(), pos[i]) - station.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="comment">// cout &lt;&lt; front &lt;&lt; &#x27; &#x27; &lt;&lt; back &lt;&lt; &#x27; &#x27; &lt;&lt; station[front] &lt;&lt; &#x27; &#x27; &lt;&lt; station[back] &lt;&lt; endl;;</span></span><br><span class="line">            <span class="keyword">if</span>(front != back) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(front);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// front == back</span></span><br><span class="line">                <span class="keyword">if</span>(front == station.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(front - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(pos[i] - station[front - <span class="number">1</span>] != station[back] - pos[i]) &#123;</span><br><span class="line">                        <span class="comment">// cout &lt;&lt; pos[i] &lt;&lt; &#x27; &#x27; &lt;&lt; station[front - 1]  &lt;&lt; &#x27; &#x27; &lt;&lt; pos[i] - station[front - 1] &lt;&lt; &#x27; &#x27; &lt;&lt; station[back] - pos[i] &lt;&lt; endl;</span></span><br><span class="line">                        <span class="keyword">if</span>(pos[i] - station[front - <span class="number">1</span>] &gt; station[back] - pos[i]) &#123;</span><br><span class="line">                            res.<span class="built_in">push_back</span>(back);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            res.<span class="built_in">push_back</span>(front - <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(front - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(front);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="风能发电"><a href="#风能发电" class="headerlink" title="风能发电"></a>风能发电</h2><p>现有一座风力发电场和<strong>容量</strong> <code>storeLimit</code> 的储能站，第 <code>j</code> 条供电指令 <code>supply[j]=[time, minSupply, maxSupply]</code> 表示时刻 <code>time</code> 起（包含该时刻）每一时刻最少供应电能 <code>minSupply</code> 以及最多供应电能 <code>maxSupply</code>，直至后续指令调整。</p>
<p>在时刻 <code>i</code> 发电量为 <code>power[i]</code>，该时刻供电逻辑如下：</p>
<ul>
<li><p>若发电量在 <code>[minSupply, maxSupply]</code> 范围内，则均供应负载；</p>
</li>
<li><p>若发电量大于 <code>maxSupply</code>，则超出部分存入储能站，存储量至多不超过 <code>storeLimit</code>；</p>
</li>
<li><p>若发电量小于</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">minSupply</span><br></pre></td></tr></table></figure>

<p>  ，则由储能站补充缺少电量，最多不超过当前存储量；</p>
<blockquote>
<p>注：储能站补充电量，直至剩余存储电量为 <code>0</code></p>
</blockquote>
</li>
</ul>
<p>请返回最后时刻（即时刻 <code>power.length-1</code>）储能站中能源总量。</p>
<p><strong>注意：</strong></p>
<ul>
<li>输入用例保证供电指令的 <code>time</code> 严格递增且第 <code>0</code> 个指令的 <code>time = 0</code></li>
<li>储能电站初始存储电量为 <code>0</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<br><code>storeLimit = 10</code><br><code>power = [1,3,4,3,6]</code><br><code>supply = [[0,2,3]]</code></p>
<p>输出: <code>4</code></p>
<p>解释：<br>时刻 0，供能 1， 新增储能 0， 总储能 0<br>时刻 1，供能 3， 新增储能 0， 总储能 0<br>时刻 2，供能 3， 新增储能 1， 总储能 1<br>时刻 3，供能 3， 新增储能 0， 总储能 1<br>时刻 4，供能 3， 新增储能 3， 总储能 4<br>因此最后时刻，剩余的能源总量为 4</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<br><code>storeLimit = 6</code><br><code>power = [6,5,2,1,0]</code><br><code>supply = [[0,1,2],[2,3,3]]</code></p>
<p>输出: <code>0</code></p>
<p>解释：<br>时刻 0，供能 2， 新增储能 4， 总储能 4<br>时刻 1，供能 2， 新增储能 2， 总储能 6 (由于储能电站达上限，电量 1 丢弃)<br>时刻 2，供能 3， 新增储能 -1， 总储能 5<br>时刻 3，供能 3， 新增储能 -2， 总储能 3<br>时刻 4，供能 3， 新增储能 -3， 总储能 0<br>因此最后时刻，剩余的能源总量为 0</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= storeLimit &lt;= 10^6</code></li>
<li><code>1 &lt;= power.length &lt;= 10^5</code></li>
<li><code>0 &lt;= power[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= supply.length &lt;= power.length</code></li>
<li>对于 <code>i &lt; j</code>，满足 <code>supply[i][0] &lt; supply[j][0]</code></li>
<li><code>supply[i].length == 3</code></li>
<li><code>0 &lt;= supply[i][0] &lt; power.length</code></li>
<li><code>0 &lt;= supply[i][1]&lt;= supply[i][2] &lt;= 10^5</code></li>
</ul>
<p>也是模拟，用map记录每个时间的最大值和最小值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">StoredEnergy</span><span class="params">(<span class="type">int</span> storeLimit, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; power, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; supply)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; hash;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : supply) &#123;</span><br><span class="line">            hash[p[<span class="number">0</span>]] = <span class="built_in">make_pair</span>(p[<span class="number">1</span>], p[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> store = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> time = supply[<span class="number">0</span>][<span class="number">0</span>], minSupply = supply[<span class="number">0</span>][<span class="number">1</span>], maxSupply = supply[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; power.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[i] != <span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">                time = i;</span><br><span class="line">                minSupply = hash[i].first;</span><br><span class="line">                maxSupply = hash[i].second;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(power[i] &gt;= minSupply &amp;&amp; power[i] &lt;= maxSupply) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(power[i] &gt;= maxSupply) &#123;</span><br><span class="line">                store += power[i] - maxSupply;</span><br><span class="line">                store = <span class="built_in">min</span>(storeLimit, store);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                store -= minSupply - power[i];</span><br><span class="line">                store = <span class="built_in">max</span>(<span class="number">0</span>, store);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> store;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="设计自动售货机"><a href="#设计自动售货机" class="headerlink" title="设计自动售货机"></a>设计自动售货机</h2><p>「银联二维码」支付可以提供简便、顺畅的消费服务，通过出示二维码或扫描二维码即可完成支付。<br>现有一台使用<strong>银联二维码</strong>进行支付的自动售货机，并对使用 银联 支付的用户提供额外的优惠服务。</p>
<blockquote>
<p>同一名顾客每成功购买一次，下次购买便可多享受 1% 的折扣（折后价<strong>向上取整</strong>），最低折扣为 70%</p>
<ul>
<li>即：第一次购买支付 100% 费用，第二次购买支付 99% 费用， 第三次购买支付 98% 费用，以此类推。</li>
</ul>
</blockquote>
<p>请你设计一个自动售货机，你需要实现一个 <code>VendingMachine</code> 类：</p>
<ul>
<li><p><code>VendingMachine()</code> —— 初始化一个 <code>VendingMachine</code> 实例</p>
</li>
<li><p><code>void addItem(int time, int number, string item, int price, int duration)</code></p>
<p> 在<code>time</code>时刻向售货机中增加<code>number</code> 个名称为<code>item</code>的商品，价格为<code>price</code>，保质期为<code>duration</code>。</p>
<ul>
<li>同种商品可能有不同批次，不同批次的价格和保质期可能不同</li>
</ul>
</li>
<li><p><code>long sell(int time, string customer, string item, int number)</code></p>
<p>   —— 在<code>time</code>时刻，名称为<code>customer</code>的顾客前来购买了<code>number</code>个名称为<code>item</code>的商品，返回总费用</p>
<ul>
<li>当且仅当售货机中存在足够数量的未过期商品方可成功购买，并返回支付的总费用，否则一件商品也不会售出，并返回 <code>-1</code></li>
<li>对于价格不同的同种商品，优先售出价格<strong>最低</strong>的商品；</li>
<li>如果有价格相同的同种商品，优先出售<strong>距离过期时间最近</strong>的商品；</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>输入保证前一次操作的 <code>time</code> 不大于后一次操作的 <code>time</code></li>
<li>过期指商品存入的时刻与保质期之和小于当前时刻，也即 <code>addtime + duration &lt; currTime</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<br><code>[&quot;VendingMachine&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;sell&quot;]</code><br><code>[[],[0,3,&quot;Apple&quot;,10,10],[1,&quot;Tom&quot;,&quot;Apple&quot;,1],[2,&quot;Tom&quot;,&quot;Apple&quot;,3],[3,&quot;Mary&quot;,&quot;Banana&quot;,2],[11,&quot;Jim&quot;,&quot;Apple&quot;,1]]</code></p>
<p>输出: <code>[null,null,10,-1,-1,-1]</code></p>
<p>解释：<br><code>VendingMachine sys = new VendingMachine();</code><br><code>sys.addItem(0,3,&quot;Apple&quot;,10,10);</code> &#x2F;&#x2F; 时刻 <code>0</code> ，添加 <code>3</code> 个 <code>Apple</code>，价格为 <code>10</code>，保质期为 <code>10</code>。<br><code>sys.sell(1,&quot;Tom&quot;,&quot;Apple&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>1</code> ，用户 <code>Tom</code> 购买 <code>1</code> 个 <code>Apple</code>， 支付 <code>10</code> ：。<br><code>sys.sell(2,&quot;Tom&quot;,&quot;Apple&quot;,3);</code> &#x2F;&#x2F; 时刻 <code>2</code> ，售货机中 <code>Apple</code> 数量为 <code>2</code> ，用户 <code>Tom</code> 购买失败，返回 <code>-1</code>。<br><code>sys.sell(3,&quot;Mary&quot;,&quot;Banana&quot;,2);</code> &#x2F;&#x2F; 时刻 <code>3</code> ，售货机中没有 <code>Banana</code> ，用户 <code>Mary</code> 购买失败，返回 <code>-1</code>。<br><code>sys.sell(11,&quot;Jim&quot;,&quot;Apple&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>11</code> ，售货机中的 <code>Apple</code> 全部过期，用户 <code>Jim</code> 购买失败，返回 <code>-1</code>。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<br><code>[&quot;VendingMachine&quot;,&quot;addItem&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;sell&quot;]</code><br><code>[[],[0,1,&quot;Apple&quot;,4,3],[1,3,&quot;Apple&quot;,4,2],[2,&quot;Mary&quot;,&quot;Apple&quot;,2],[2,1,&quot;Banana&quot;,2,5],[4,&quot;Jim&quot;,&quot;Banana&quot;,2],[4,&quot;Mary&quot;,&quot;Banana&quot;,1],[4,&quot;Mary&quot;,&quot;Apple&quot;,1],[6,200,&quot;Apple&quot;,2,5],[6,&quot;Jim&quot;,&quot;Apple&quot;,100],[7,&quot;Mary&quot;,&quot;Apple&quot;,100]]</code></p>
<p>输出: <code>[null,null,null,8,null,-1,2,-1,null,200,196]</code></p>
<p>解释：<br><code>VendingMachine sys = new VendingMachine();</code><br><code>sys.addItem(0,1,&quot;Apple&quot;,4,3);</code> &#x2F;&#x2F; 时刻 <code>0</code> ，添加 <code>1</code> 个 <code>Apple</code>，价格为 <code>4</code>，保质期为 <code>3</code>。<br><code>sys.addItem(1,3,&quot;Apple&quot;,4,2);</code> &#x2F;&#x2F; 时刻 <code>1</code> ，添加 <code>3</code> 个 <code>Apple</code>，价格为 <code>4</code>，保质期为 <code>2</code>。<br><code>sys.sell(2,&quot;Mary&quot;,&quot;Apple&quot;,2);</code> &#x2F;&#x2F; 时刻 <code>2</code> ，用户 <code>Mary</code> 购买 <code>2</code> 个 <code>Apple</code>，支付 <code>8</code>。<br><code>sys.addItem(2,1,&quot;Banana&quot;,2,5);</code> &#x2F;&#x2F; 时刻 <code>2</code> ，添加 <code>1</code> 个 <code>Banana</code>，价格为 <code>2</code>，保质期为 <code>5</code>。<br><code>sys.sell(4,&quot;Jim&quot;,&quot;Banana&quot;,2);</code> &#x2F;&#x2F; 时刻 <code>4</code> ，售货机中 <code>Banana</code> 数量为 <code>1</code> ，用户 <code>Jim</code> 购买失败，返回 <code>-1</code>。<br><code>sys.sell(4,&quot;Mary&quot;,&quot;Banana&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>4</code> ，用户 <code>Mary</code> 购买 <code>1</code> 个 <code>Banana</code>，享受 1% 的优惠，向上取整后为 <code>2</code><br><code>sys.sell(4,&quot;Mary&quot;,&quot;Apple&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>4</code> ，售货机中的 <code>Apple</code> 全部过期，用户 <code>Mary</code> 购买失败，返回 <code>-1</code>。<br><code>sys.addItem(6,200,&quot;Apple&quot;,2,5);</code> &#x2F;&#x2F; 时刻 <code>6</code> ，添加 <code>200</code> 个 <code>Apple</code>，价格为 <code>2</code>，保质期为 <code>5</code>。<br><code>sys.sell(6,&quot;Jim&quot;,&quot;Apple&quot;,100);</code> &#x2F;&#x2F; 时刻 <code>6</code> ，用户 <code>Jim</code> 购买 <code>100</code> 个 <code>Apple</code>。返回 200<br><code>sys.sell(7,&quot;Mary&quot;,&quot;Apple&quot;,100);</code> &#x2F;&#x2F; 时刻 <code>7</code> ，用户 <code>Mary</code> 购买 <code>100</code> 个 <code>Apple</code>，可享受 2% 的优惠。返回196</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= item.length,customer.length &lt;= 10</code>，<code>item</code> 和 <code>customer</code> 中只包含英文字母</li>
<li><code>1 &lt;= duration,price,number &lt;= 10^6</code></li>
<li><code>0 &lt;= time &lt;= 10^6</code></li>
<li><code>addItem</code> 和 <code>sell</code> 的总调用次数不超过 <code>1000</code> 次</li>
</ul>
<p>关键是如何高效存储信息。</p>
<p>因为不能出售过期商品，而且售卖时间是递增的，所以每次售卖遍历过期商品的操作是多余，我们可以在售卖前删除过期商品，删除后本次遍历的商品都是可以购买的，不用担心过期问题。为了方便的去掉过期商品，可以创建<code>tuple&lt;time, item, price</code>小根堆，堆内会依次对关键词排序，实际我们只关心<code>time</code>，去除的时候只需要挨个遍历，堆内的<code>time</code>是递增的；</p>
<p>出售时，获取<code>item</code>在不同<code>&#123;end_time, price&#125;</code>的数量，可以用<code>map</code>来存储；</p>
<p>因为只有数量够客户的购买量，才会更新<code>item</code>的信息，如果在最后一步才发现数量不够，还需要回退更新操作，比较麻烦，而且时间上可能会超时，所以用<code>map</code>标记一下每个<code>item</code>的总量，如果数量够则放心更新信息，不够则直接返回<code>-1</code>；</p>
<p>因为客户每成功购买一次商品折扣就要少一个点，所以用<code>map</code>标记一下<code>customer</code>成功购买次数；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VendingMachine</span> &#123;</span><br><span class="line">    priority_queue&lt;tuple&lt;<span class="type">int</span>, string, <span class="type">int</span>&gt;, vector&lt;tuple&lt;<span class="type">int</span>, string, <span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt; item_time;</span><br><span class="line">    map&lt;string, map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt;&gt; item_info; </span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; user_cnt;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; item_cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VendingMachine</span>() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addItem</span><span class="params">(<span class="type">int</span> time, <span class="type">int</span> number, string item, <span class="type">int</span> price, <span class="type">int</span> duration)</span> </span>&#123;</span><br><span class="line">        item_time.<span class="built_in">push</span>(<span class="built_in">make_tuple</span>(time + duration, item, price));</span><br><span class="line">        item_info[item][<span class="built_in">make_pair</span>(price, time + duration)] += number;</span><br><span class="line">        item_cnt[item] += number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sell</span><span class="params">(<span class="type">int</span> time, string customer, string item, <span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!item_time.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(item_time.<span class="built_in">top</span>()) &lt; time) &#123;</span><br><span class="line">            <span class="type">int</span> _time = <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(item_time.<span class="built_in">top</span>());</span><br><span class="line">            string _item = <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(item_time.<span class="built_in">top</span>());</span><br><span class="line">            <span class="type">int</span> _price = <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(item_time.<span class="built_in">top</span>());</span><br><span class="line">            item_cnt[_item] -= item_info[_item][<span class="built_in">make_pair</span>(_price, _time)];</span><br><span class="line">            item_info[_item].<span class="built_in">erase</span>(<span class="built_in">make_pair</span>(_price, _time));</span><br><span class="line">            item_time.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(item_cnt[item] &lt; number) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> buy_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> price = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(buy_cnt &lt; number) &#123;</span><br><span class="line">            <span class="type">int</span> _price = item_info[item].<span class="built_in">begin</span>() -&gt; first.first;</span><br><span class="line">            <span class="type">int</span> _time = item_info[item].<span class="built_in">begin</span>() -&gt; first.second;</span><br><span class="line">            <span class="type">int</span> _num = item_info[item].<span class="built_in">begin</span>() -&gt; second;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;_num &quot; &lt;&lt; _num &lt;&lt; &quot; &quot;;</span></span><br><span class="line">            item_info[item].<span class="built_in">erase</span>(<span class="built_in">make_pair</span>(_price, _time));</span><br><span class="line">            <span class="type">int</span> cnt = <span class="built_in">min</span>(number - buy_cnt, _num);</span><br><span class="line">            buy_cnt += cnt;</span><br><span class="line">            price += <span class="number">1ll</span> * cnt * _price;</span><br><span class="line">            <span class="keyword">if</span>(_num &gt; cnt) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;item_info[item][make_pair(_price, _time)] &quot; &lt;&lt; item_info[item][make_pair(_price, _time)] &lt;&lt; endl;</span></span><br><span class="line">                item_info[item][<span class="built_in">make_pair</span>(_price, _time)] = _num - cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        item_cnt[item] -= number;</span><br><span class="line">        price = (price * <span class="built_in">max</span>(<span class="number">70</span>, (<span class="number">100</span> - user_cnt[customer])) - <span class="number">1</span>) * <span class="number">0.01</span> + <span class="number">1</span>;</span><br><span class="line">        user_cnt[customer] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your VendingMachine object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * VendingMachine* obj = new VendingMachine();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addItem(time,number,item,price,duration);</span></span><br><span class="line"><span class="comment"> * long long param_2 = obj-&gt;sell(time,customer,item,number);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>分布式Raft算法</title>
    <url>/2023/04/28/%E5%88%86%E5%B8%83%E5%BC%8FRaft%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>动态代理和静态代理</title>
    <url>/2023/04/29/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>如何设计一个秒杀系统</title>
    <url>/2023/05/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2023/05/06/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>家谱树</title>
    <url>/2022/11/07/%E5%AE%B6%E8%B0%B1%E6%A0%91/</url>
    <content><![CDATA[<p>有个人的家族很大，辈分关系很混乱，请你帮整理一下这种关系。</p>
<p>给出每个人的孩子的信息。</p>
<p>输出一个序列，使得每个人的孩子都比那个人后列出。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第 1 行一个整数 n ，表示家族的人数；</p>
<p>接下来 n 行，第 i 行描述第 i 个人的孩子；</p>
<p>每行最后是 0 表示描述完毕。</p>
<p>每个人的编号从 1 到 n。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个序列，使得每个人的孩子都比那个人后列出；</p>
<p>数据保证一定有解，如果有多解输出任意一解。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 &lt;&#x3D; n &lt;&#x3D; 100</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">0</span><br><span class="line">4 5 1 0</span><br><span class="line">1 0</span><br><span class="line">5 3 0</span><br><span class="line">3 0</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 4 5 3 1</span><br></pre></td></tr></table></figure>

<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p>邻接表存图，先把入度为0的点进队列，然后不断的取出队列的头结点，每次将头结点的所连的节点的入度减一，如果所连节点的度数减少为0，则将此节点进入队列，直到队列为空。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>, M = N * N / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[idx] = y, ne[idx] = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!d[i]) q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line">        <span class="type">int</span> x = q[hh++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; ~i; i = ne[i]) &#123;</span><br><span class="line">            <span class="type">int</span> y = e[i];</span><br><span class="line">            <span class="keyword">if</span> (--d[y] == <span class="number">0</span>) q[++tt] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> son;</span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; son, son) &#123;</span><br><span class="line">            <span class="built_in">add</span>(i, son);</span><br><span class="line">            d[son]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/2023/04/29/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>序列化工具（kryo、hessian、java、protostuff）</title>
    <url>/2023/04/28/%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7%EF%BC%88kryo%E3%80%81hessian%E3%80%81java%E3%80%81protostuff%EF%BC%89/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>接雨水</title>
    <url>/2023/05/03/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数据库和缓存如何保证一致性</title>
    <url>/2023/04/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>搭配购买</title>
    <url>/2023/02/01/%E6%90%AD%E9%85%8D%E8%B4%AD%E4%B9%B0/</url>
    <content><![CDATA[<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>Joe觉得云朵很美，决定去山上的商店买一些云朵。</p>
<p>商店里有 $n$朵云，云朵被编号为$1,2,…,n$，并且每朵云都有一个价值。</p>
<p>但是商店老板跟他说，一些云朵要搭配来买才好，所以买一朵云则与这朵云有搭配的云都要买。</p>
<p>但是Joe的钱有限，所以他希望买的价值越多越好。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第 11 行包含三个整数$ n，m，w$，表示有$n$朵云，$m$个搭配，Joe有$w$的钱。</p>
<p>第$2∼n+1$行，每行两个整数 $ci，di$，表示$ i$ 朵云的价钱和价值。</p>
<p>第$n+2∼n+1+m$行，每行两个整数$ui，vi$，表示买$ui$就必须买$vi$，同理，如果买$vi$就必须买$ui$。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>一行，表示可以获得的最大价值。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N], v[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x]) fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, _w;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; _w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(fx != fy) &#123;</span><br><span class="line">            w[fx] += w[fy];</span><br><span class="line">            v[fx] += v[fy];</span><br><span class="line">            fa[fy] = fx;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == fa[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = _w; j &gt;= w[i]; j--) &#123;</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[_w] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>并查集、01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>滑雪车</title>
    <url>/2022/11/08/%E6%BB%91%E9%9B%AA%E8%BD%A6/</url>
    <content><![CDATA[<p>随着白天越来越短夜晚越来越长，我们不得不考虑铲雪问题了。</p>
<p>整个城市所有的道路都是双向车道,道路的两个方向均需要铲雪。因为城市预算的削减，整个城市只有 1 辆铲雪车。</p>
<p>铲雪车只能把它开过的地方（车道）的雪铲干净，无论哪儿有雪，铲雪车都得从停放的地方出发，游历整个城市的街道。</p>
<p>现在的问题是：最少要花多少时间去铲掉所有道路上的雪呢？</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入数据的第$1$行表示铲雪车的停放坐标$(x,y)$，$x$，$y$为整数，单位为米。</p>
<p>下面最多有$4000$行，每行给出了一条街道的起点坐标和终点坐标，坐标均为整数，所有街道都是笔直的，且都是双向车道。</p>
<p>铲雪车可以在任意交叉口、或任何街道的末尾任意转向，包括转$U$型弯。</p>
<p>铲雪车铲雪时前进速度为 $20$千米&#x2F;时，不铲雪时前进速度为$50$千米&#x2F;时。</p>
<p>保证：铲雪车从起点一定可以到达任何街道。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出铲掉所有街道上的雪并且返回出发点的最短时间，精确到分钟，四舍五入到整数。</p>
<p>输出格式为$hours:minutes$，$minutes$不足两位数时需要补前导零。<br>具体格式参照样例。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$−10^6\leq x, y≤10^6$<br>所有位置坐标绝对值不超过 $10^6$</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0</span><br><span class="line">0 0 10000 10000</span><br><span class="line">5000 -10000 5000 10000</span><br><span class="line">5000 10000 10000 10000</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3:55</span><br></pre></td></tr></table></figure>

<h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>输出结果表示共需3小时55分钟。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>这个题貌似很复杂，其实可以发现每条路都是双向通路，所以存在欧拉回路，意味着我们可以选择任意一点作为起始点，不重不漏的走完所有的边再回到起点，然后反向再走一遍就可以打扫完所有的积雪。</p>
<p>可以发现$50$千米&#x2F;小时的速度用不上，$50$千米&#x2F;小时的速度必须是行驶在一条没有雪的边上才可以达到的，意味着这条边已经来回走了一遍。但是我们从起点走到起点，再从起点反着走到起点就已经把所有的道路积雪清理完毕，自始至终都是以$20$千米&#x2F;小时的速度前进。</p>
<p>故求出所有边的长度 * $2$ 就是行驶距离，然后再进行小时和分钟的计算。</p>
<p>有向图中<strong>欧拉回路</strong>存在的充要条件是所有点的出度等于入度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> x1, y1, x2, y2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>, &amp;x1, &amp;y1);</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf %lf&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2)) &#123;</span><br><span class="line">        <span class="type">double</span> dx = x1 - x2;</span><br><span class="line">        <span class="type">double</span> dy = y1 - y2;</span><br><span class="line">        sum += <span class="built_in">sqrt</span>(dx * dx + dy * dy) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> minutes = <span class="built_in">round</span>(sum / <span class="number">1000</span> / <span class="number">20</span> * <span class="number">60</span>);</span><br><span class="line">    <span class="type">int</span> hours = minutes / <span class="number">60</span>;</span><br><span class="line">    minutes %= <span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%02d\n&quot;</span>, hours, minutes);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载器</title>
    <url>/2023/04/23/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2023/04/28/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>线程模型</title>
    <url>/2023/05/06/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计算机网络分层模型</title>
    <url>/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
