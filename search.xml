<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/09/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode第87场双周赛</title>
    <url>/2022/09/22/leetcode%E7%AC%AC87%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="共同度过的日子"><a href="#共同度过的日子" class="headerlink" title="共同度过的日子"></a>共同度过的日子</h2><p>Alice 和 Bob 计划分别去罗马开会。</p>
<p>给你四个字符串 arriveAlice ，leaveAlice ，arriveBob 和 leaveBob 。Alice 会在日期 arriveAlice 到 leaveAlice 之间在城市里（日期为闭区间），而 Bob 在日期 arriveBob 到 leaveBob 之间在城市里（日期为闭区间）。每个字符串都包含 5 个字符，格式为 “MM-DD” ，对应着一个日期的月和日。</p>
<p>请你返回 Alice和 Bob 同时在罗马的天数。</p>
<p>你可以假设所有日期都在 同一个 自然年，而且 不是 闰年。每个月份的天数分别为：[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] 。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：arriveAlice &#x3D; “08-15”, leaveAlice &#x3D; “08-18”, arriveBob &#x3D; “08-16”, leaveBob &#x3D; “08-19”<br>输出：3<br>解释：Alice 从 8 月 15 号到 8 月 18 号在罗马。Bob 从 8 月 16 号到 8 月 19 号在罗马，他们同时在罗马的日期为 8 月 16、17 和 18 号。所以答案为 3 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：arriveAlice &#x3D; “10-01”, leaveAlice &#x3D; “10-31”, arriveBob &#x3D; “11-01”, leaveBob &#x3D; “12-31”<br>输出：0<br>解释：Alice 和 Bob 没有同时在罗马的日子，所以我们返回 0 。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>所有日期的格式均为 “MM-DD” 。</li>
<li>Alice 和 Bob 的到达日期都 早于或等于 他们的离开日期。</li>
<li>题目测试用例所给出的日期均为 非闰年 的有效日期。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> months[<span class="number">13</span>] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">days</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> month, day;</span><br><span class="line">        <span class="built_in">sscanf</span>(s.<span class="built_in">c_str</span>(), <span class="string">&quot;%d-%d&quot;</span>, &amp;month, &amp;day);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; month; i++) &#123;</span><br><span class="line">            sum += months[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sum += day;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDaysTogether</span><span class="params">(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(<span class="built_in">days</span>(leaveAlice), <span class="built_in">days</span>(leaveBob)) - <span class="built_in">max</span>(<span class="built_in">days</span>(arriveAlice), <span class="built_in">days</span>(arriveBob)) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="运动员和训练师的最大匹配数"><a href="#运动员和训练师的最大匹配数" class="headerlink" title="运动员和训练师的最大匹配数"></a>运动员和训练师的最大匹配数</h2><p>给你一个下标从 0 开始的整数数组 players ，其中 players[i] 表示第 i 名运动员的 能力 值，同时给你一个下标从 0 开始的整数数组 trainers ，其中 trainers[j] 表示第 j 名训练师的 训练能力值 。</p>
<p>如果第 i 名运动员的能力值 小于等于 第 j 名训练师的能力值，那么第 i 名运动员可以 匹配 第 j 名训练师。除此以外，每名运动员至多可以匹配一位训练师，每位训练师最多可以匹配一位运动员。</p>
<p>请你返回满足上述要求 players 和 trainers 的 最大 匹配数。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：players &#x3D; [4,7,9], trainers &#x3D; [8,2,5,8]<br>输出：2<br>解释：<br>得到两个匹配的一种方案是：</p>
<p>players[0] 与 trainers[0] 匹配，因为 4 &lt;&#x3D; 8 。</p>
<p>players[1] 与 trainers[3] 匹配，因为 7 &lt;&#x3D; 8 。<br>可以证明 2 是可以形成的最大匹配数。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：players &#x3D; [1,1,1], trainers &#x3D; [10]<br>输出：1<br>解释：<br>训练师可以匹配所有 3 个运动员<br>每个运动员至多只能匹配一个训练师，所以最大答案是 1 。</p>
</blockquote>
<p>提示：</p>
<ul>
<li><code>1 &lt;= players.length, trainers.length &lt;= 105</code></li>
<li><code>1 &lt;= players[i], trainers[j] &lt;= 109</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">matchPlayersAndTrainers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; players, vector&lt;<span class="type">int</span>&gt;&amp; trainers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(players.<span class="built_in">begin</span>(), players.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(trainers.<span class="built_in">begin</span>(), trainers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; players.<span class="built_in">size</span>() &amp;&amp; j &lt; trainers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; trainers.<span class="built_in">size</span>() &amp;&amp; players[i] &gt; trainers[j]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; trainers.<span class="built_in">size</span>() &amp;&amp; trainers[j] &gt;= trainers[i]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="按位或最大的最小子数组长度"><a href="#按位或最大的最小子数组长度" class="headerlink" title="按位或最大的最小子数组长度"></a>按位或最大的最小子数组长度</h2><p>给你一个长度为 n 下标从 0 开始的数组 nums ，数组中所有数字均为非负整数。对于 0 到 n - 1 之间的每一个下标 i ，你需要找出 nums 中一个 最小 非空子数组，它的起始位置为 i （包含这个位置），同时有 最大 的 按位或运算值 。</p>
<ul>
<li>换言之，令 Bij 表示子数组 nums[i…j] 的按位或运算的结果，你需要找到一个起始位置为 i 的最小子数组，这个子数组的按位或运算的结果等于 max(Bik) ，其中 i &lt;&#x3D; k &lt;&#x3D; n - 1 。<br>  一个数组的按位或运算值是这个数组里所有数字按位或运算的结果。</li>
</ul>
<p>请你返回一个大小为 n 的整数数组 answer，其中 answer[i]是开始位置为 i ，按位或运算结果最大，且 最短 子数组的长度。</p>
<p>子数组 是数组里一段连续非空元素组成的序列。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：nums &#x3D; [1,0,2,1,3]<br>输出：[3,3,2,2,1]<br>解释：<br>任何位置开始，最大按位或运算的结果都是 3 。</p>
<ul>
<li>下标 0 处，能得到结果 3 的最短子数组是 [1,0,2] 。</li>
<li>下标 1 处，能得到结果 3 的最短子数组是 [0,2,1] 。</li>
<li>下标 2 处，能得到结果 3 的最短子数组是 [2,1] 。</li>
<li>下标 3 处，能得到结果 3 的最短子数组是 [1,3] 。</li>
<li>下标 4 处，能得到结果 3 的最短子数组是 [3] 。<br>所以我们返回 [3,3,2,2,1] 。</li>
</ul>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：nums &#x3D; [1,2]<br>输出：[2,1]<br>解释：<br>下标 0 处，能得到最大按位或运算值的最短子数组长度为 2 。<br>下标 1 处，能得到最大按位或运算值的最短子数组长度为 1 。<br>所以我们返回 [2,1] 。</p>
</blockquote>
<p><strong>题解：</strong></p>
<p>逆序遍历，因为是要求最短，所以记录每一位的<code>1</code>第一次出现的位置，又因为要求或运算最大，所以还需要对每一位<code>1</code></p>
<p>第一次出现的位置取最大值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">smallestSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">30</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> index = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">30</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt;&gt; j &amp; <span class="number">1</span>) a[j] = i;</span><br><span class="line">                index = <span class="built_in">max</span>(index, a[j]);</span><br><span class="line">            &#125;      </span><br><span class="line">            res[i] = index - i + <span class="number">1</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="完成所有交易的初始最少钱数"><a href="#完成所有交易的初始最少钱数" class="headerlink" title="完成所有交易的初始最少钱数"></a>完成所有交易的初始最少钱数</h2><p>给你一个下标从 0 开始的二维整数数组 transactions，其中transactions[i] &#x3D; [costi, cashbacki] 。</p>
<p>数组描述了若干笔交易。其中每笔交易必须以 某种顺序 恰好完成一次。在任意一个时刻，你有一定数目的钱 money ，为了完成交易 i ，money &gt;&#x3D; costi 这个条件必须为真。执行交易后，你的钱数 money 变成 money - costi + cashbacki 。</p>
<p>请你返回 任意一种 交易顺序下，你都能完成所有交易的最少钱数 money 是多少。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：transactions &#x3D; [[2,1],[5,0],[4,2]]<br>输出：10<br>解释：<br>刚开始 money &#x3D; 10 ，交易可以以任意顺序进行。<br>可以证明如果 money &lt; 10 ，那么某些交易无法进行。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：transactions &#x3D; [[3,0],[0,3]]<br>输出：3<br>解释：</p>
<ul>
<li>如果交易执行的顺序是 [[3,0],[0,3]] ，完成所有交易需要的最少钱数是 3 。</li>
<li>如果交易执行的顺序是 [[0,3],[3,0]] ，完成所有交易需要的最少钱数是 0 。<br>所以，刚开始钱数为 3 ，任意顺序下交易都可以全部完成。</li>
</ul>
</blockquote>
<p><strong>题解：</strong></p>
<p>下一笔交易能够进行一定满足条件</p>
<blockquote>
<p>money - (cost_1 - back_1) + (cost_2 - back_2) … &gt;&#x3D; cost_i</p>
<p>那么money &gt;&#x3D;   (cost_1 - back_1) + (cost_2 - back_2) + cost_i</p>
<p>最少钱数money等于右侧最大值，右侧表示按照某种顺序，进行第i笔交易时，达到了最大钱数。</p>
<p>右侧由两部分组成， (cost_1 - back_1) + (cost_2 - back_2) 和 cost_i</p>
<p>要整体达到最大值，所以这两部分也需要达到最大值。</p>
<p>第一部分，统计所有cost  &gt; back 和合。</p>
<p>第二部分，我们无法直接得出cost_i在哪笔交易中，但是我们可以通过枚举所有交易。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minimumMoney</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; transactions)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : transactions) &#123;</span><br><span class="line">            <span class="type">int</span> cost = p[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> cashback = p[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(cost &gt; cashback) &#123;</span><br><span class="line">                sum += cost - cashback;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : transactions) &#123;</span><br><span class="line">            <span class="type">int</span> cost = p[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> cashback = p[<span class="number">1</span>];</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> s = sum;</span><br><span class="line">            <span class="keyword">if</span>(cost &gt; cashback) &#123;</span><br><span class="line">                s -= cost - cashback;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, s + cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>中国银联专场竞赛（2023届校园招聘专场）</title>
    <url>/2022/10/02/%E4%B8%AD%E5%9B%BD%E9%93%B6%E8%81%94%E4%B8%93%E5%9C%BA%E7%AB%9E%E8%B5%9B%EF%BC%882023%E5%B1%8A%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E4%B8%93%E5%9C%BA%EF%BC%89/</url>
    <content><![CDATA[<h2 id="重构链表"><a href="#重构链表" class="headerlink" title="重构链表"></a>重构链表</h2><p>给定一个链表的头节点 <code>head</code> ，在不改变节点顺序的基础下，请删除链表中所有值为 <code>偶数</code> 的节点，并返回这个链表 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>若链表为空，则返回空值。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<code>head = [1,4,3,6]</code></p>
<p>输出：<code>[1,3]</code></p>
<p>解释：如下图所示，黑色节点的值均为偶数，删除这些节点后，链表为 <code>[1,3]</code><br><img src="https://pic.leetcode-cn.com/1663123060-ffBMiH-image.png" alt="image.png"></p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<code>head = [5,7,9,9,1]</code></p>
<p>输出：<code>[5,7,9,9,1]</code></p>
<p>解释：原链表中不存在值为偶数的节点。</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入：<code>head = [2,4]</code></p>
<p>输出：<code>[]</code></p>
<p>解释：原链表中所有节点值均为偶数。</p>
</blockquote>
<p><strong>提示：</strong><br><code>1 &lt;= head.length &lt;= 10^5</code><br><code>0 &lt;= Node.val &lt;= 100</code></p>
<p>创建虚拟头节点，然后遍历链表，用cur指针去更新虚拟节点的后继。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reContruct</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(head -&gt; val % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                head = head -&gt; next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur -&gt; next = head;</span><br><span class="line">            head = head -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="勘探补给"><a href="#勘探补给" class="headerlink" title="勘探补给"></a>勘探补给</h2><p>工程部在一条坐标轴上设立了若干补给站，<code>station[i]</code> 表示编号为 <code>i</code> 的补给站的坐标。</p>
<p>现在有一些正在执行任务的勘探队需要进行补给，<code>pos[i]</code> 表示第 <code>i</code> 个勘探队当前所在位置的坐标。勘探队将优先选择<strong>当前距离最近</strong>的补给站进行补给。若两座补给站距离相同，则选择坐标更小的那一个。</p>
<p><strong>请按顺序</strong>返回这些勘探队所选择的补给站编号。</p>
<p><strong>注意：</strong></p>
<ul>
<li><code>station</code> 中的元素严格递增，即 <code>station[i] &lt; station[i+1]</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<br><code>station = [2,7,8,10]</code><br><code>pos = [4,9]</code><br>输出：<br><code>[0,2]</code><br>解释：<br>坐标 <code>4</code> 的勘探队与坐标为 <code>2</code> 和 <code>7</code> 的补给站距离分别为 <code>2</code> 和 <code>3</code>， 选择坐标为 <code>2</code>的补给站<br>坐标 <code>9</code> 的勘探队与坐标为 <code>8</code> 和 <code>10</code> 的补给站的距离均为 <code>1</code>， 选择坐标更小为 <code>8</code> 的补给站<br>返回编号为 <code>[0,2]</code> 的补给站。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<br><code>station = [2,5,8,14,17]</code><br><code>pos = [1,14,11,2]</code><br>输出：<br><code>[0,3,2,0]</code></p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= pos.length,station.length &lt;= 10^4</code></li>
<li><code>1 &lt;= pos[i] &lt;= 10^6</code></li>
<li><code>1 &lt;= station[i] &lt; station[i+1] &lt;= 10^6</code></li>
</ul>
<p>模拟即可，寻找的时候用二分即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">explorationSupply</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; station, vector&lt;<span class="type">int</span>&gt;&amp; pos)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = pos.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(station.<span class="built_in">begin</span>(), station.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> front = <span class="built_in">lower_bound</span>(station.<span class="built_in">begin</span>(), station.<span class="built_in">end</span>(), pos[i]) - station.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> back = <span class="built_in">upper_bound</span>(station.<span class="built_in">begin</span>(), station.<span class="built_in">end</span>(), pos[i]) - station.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="comment">// cout &lt;&lt; front &lt;&lt; &#x27; &#x27; &lt;&lt; back &lt;&lt; &#x27; &#x27; &lt;&lt; station[front] &lt;&lt; &#x27; &#x27; &lt;&lt; station[back] &lt;&lt; endl;;</span></span><br><span class="line">            <span class="keyword">if</span>(front != back) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(front);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// front == back</span></span><br><span class="line">                <span class="keyword">if</span>(front == station.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(front - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(pos[i] - station[front - <span class="number">1</span>] != station[back] - pos[i]) &#123;</span><br><span class="line">                        <span class="comment">// cout &lt;&lt; pos[i] &lt;&lt; &#x27; &#x27; &lt;&lt; station[front - 1]  &lt;&lt; &#x27; &#x27; &lt;&lt; pos[i] - station[front - 1] &lt;&lt; &#x27; &#x27; &lt;&lt; station[back] - pos[i] &lt;&lt; endl;</span></span><br><span class="line">                        <span class="keyword">if</span>(pos[i] - station[front - <span class="number">1</span>] &gt; station[back] - pos[i]) &#123;</span><br><span class="line">                            res.<span class="built_in">push_back</span>(back);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            res.<span class="built_in">push_back</span>(front - <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(front - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(front);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="风能发电"><a href="#风能发电" class="headerlink" title="风能发电"></a>风能发电</h2><p>现有一座风力发电场和<strong>容量</strong> <code>storeLimit</code> 的储能站，第 <code>j</code> 条供电指令 <code>supply[j]=[time, minSupply, maxSupply]</code> 表示时刻 <code>time</code> 起（包含该时刻）每一时刻最少供应电能 <code>minSupply</code> 以及最多供应电能 <code>maxSupply</code>，直至后续指令调整。</p>
<p>在时刻 <code>i</code> 发电量为 <code>power[i]</code>，该时刻供电逻辑如下：</p>
<ul>
<li><p>若发电量在 <code>[minSupply, maxSupply]</code> 范围内，则均供应负载；</p>
</li>
<li><p>若发电量大于 <code>maxSupply</code>，则超出部分存入储能站，存储量至多不超过 <code>storeLimit</code>；</p>
</li>
<li><p>若发电量小于</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">minSupply</span><br></pre></td></tr></table></figure>

<p>  ，则由储能站补充缺少电量，最多不超过当前存储量；</p>
<blockquote>
<p>注：储能站补充电量，直至剩余存储电量为 <code>0</code></p>
</blockquote>
</li>
</ul>
<p>请返回最后时刻（即时刻 <code>power.length-1</code>）储能站中能源总量。</p>
<p><strong>注意：</strong></p>
<ul>
<li>输入用例保证供电指令的 <code>time</code> 严格递增且第 <code>0</code> 个指令的 <code>time = 0</code></li>
<li>储能电站初始存储电量为 <code>0</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<br><code>storeLimit = 10</code><br><code>power = [1,3,4,3,6]</code><br><code>supply = [[0,2,3]]</code></p>
<p>输出: <code>4</code></p>
<p>解释：<br>时刻 0，供能 1， 新增储能 0， 总储能 0<br>时刻 1，供能 3， 新增储能 0， 总储能 0<br>时刻 2，供能 3， 新增储能 1， 总储能 1<br>时刻 3，供能 3， 新增储能 0， 总储能 1<br>时刻 4，供能 3， 新增储能 3， 总储能 4<br>因此最后时刻，剩余的能源总量为 4</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<br><code>storeLimit = 6</code><br><code>power = [6,5,2,1,0]</code><br><code>supply = [[0,1,2],[2,3,3]]</code></p>
<p>输出: <code>0</code></p>
<p>解释：<br>时刻 0，供能 2， 新增储能 4， 总储能 4<br>时刻 1，供能 2， 新增储能 2， 总储能 6 (由于储能电站达上限，电量 1 丢弃)<br>时刻 2，供能 3， 新增储能 -1， 总储能 5<br>时刻 3，供能 3， 新增储能 -2， 总储能 3<br>时刻 4，供能 3， 新增储能 -3， 总储能 0<br>因此最后时刻，剩余的能源总量为 0</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= storeLimit &lt;= 10^6</code></li>
<li><code>1 &lt;= power.length &lt;= 10^5</code></li>
<li><code>0 &lt;= power[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= supply.length &lt;= power.length</code></li>
<li>对于 <code>i &lt; j</code>，满足 <code>supply[i][0] &lt; supply[j][0]</code></li>
<li><code>supply[i].length == 3</code></li>
<li><code>0 &lt;= supply[i][0] &lt; power.length</code></li>
<li><code>0 &lt;= supply[i][1]&lt;= supply[i][2] &lt;= 10^5</code></li>
</ul>
<p>也是模拟，用map记录每个时间的最大值和最小值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">StoredEnergy</span><span class="params">(<span class="type">int</span> storeLimit, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; power, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; supply)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; hash;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : supply) &#123;</span><br><span class="line">            hash[p[<span class="number">0</span>]] = <span class="built_in">make_pair</span>(p[<span class="number">1</span>], p[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> store = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> time = supply[<span class="number">0</span>][<span class="number">0</span>], minSupply = supply[<span class="number">0</span>][<span class="number">1</span>], maxSupply = supply[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; power.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[i] != <span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">                time = i;</span><br><span class="line">                minSupply = hash[i].first;</span><br><span class="line">                maxSupply = hash[i].second;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(power[i] &gt;= minSupply &amp;&amp; power[i] &lt;= maxSupply) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(power[i] &gt;= maxSupply) &#123;</span><br><span class="line">                store += power[i] - maxSupply;</span><br><span class="line">                store = <span class="built_in">min</span>(storeLimit, store);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                store -= minSupply - power[i];</span><br><span class="line">                store = <span class="built_in">max</span>(<span class="number">0</span>, store);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> store;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="设计自动售货机"><a href="#设计自动售货机" class="headerlink" title="设计自动售货机"></a>设计自动售货机</h2><p>「银联二维码」支付可以提供简便、顺畅的消费服务，通过出示二维码或扫描二维码即可完成支付。<br>现有一台使用<strong>银联二维码</strong>进行支付的自动售货机，并对使用 银联 支付的用户提供额外的优惠服务。</p>
<blockquote>
<p>同一名顾客每成功购买一次，下次购买便可多享受 1% 的折扣（折后价<strong>向上取整</strong>），最低折扣为 70%</p>
<ul>
<li>即：第一次购买支付 100% 费用，第二次购买支付 99% 费用， 第三次购买支付 98% 费用，以此类推。</li>
</ul>
</blockquote>
<p>请你设计一个自动售货机，你需要实现一个 <code>VendingMachine</code> 类：</p>
<ul>
<li><p><code>VendingMachine()</code> —— 初始化一个 <code>VendingMachine</code> 实例</p>
</li>
<li><p><code>void addItem(int time, int number, string item, int price, int duration)</code></p>
<p> 在<code>time</code>时刻向售货机中增加<code>number</code> 个名称为<code>item</code>的商品，价格为<code>price</code>，保质期为<code>duration</code>。</p>
<ul>
<li>同种商品可能有不同批次，不同批次的价格和保质期可能不同</li>
</ul>
</li>
<li><p><code>long sell(int time, string customer, string item, int number)</code></p>
<p>   —— 在<code>time</code>时刻，名称为<code>customer</code>的顾客前来购买了<code>number</code>个名称为<code>item</code>的商品，返回总费用</p>
<ul>
<li>当且仅当售货机中存在足够数量的未过期商品方可成功购买，并返回支付的总费用，否则一件商品也不会售出，并返回 <code>-1</code></li>
<li>对于价格不同的同种商品，优先售出价格<strong>最低</strong>的商品；</li>
<li>如果有价格相同的同种商品，优先出售<strong>距离过期时间最近</strong>的商品；</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>输入保证前一次操作的 <code>time</code> 不大于后一次操作的 <code>time</code></li>
<li>过期指商品存入的时刻与保质期之和小于当前时刻，也即 <code>addtime + duration &lt; currTime</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<br><code>[&quot;VendingMachine&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;sell&quot;]</code><br><code>[[],[0,3,&quot;Apple&quot;,10,10],[1,&quot;Tom&quot;,&quot;Apple&quot;,1],[2,&quot;Tom&quot;,&quot;Apple&quot;,3],[3,&quot;Mary&quot;,&quot;Banana&quot;,2],[11,&quot;Jim&quot;,&quot;Apple&quot;,1]]</code></p>
<p>输出: <code>[null,null,10,-1,-1,-1]</code></p>
<p>解释：<br><code>VendingMachine sys = new VendingMachine();</code><br><code>sys.addItem(0,3,&quot;Apple&quot;,10,10);</code> &#x2F;&#x2F; 时刻 <code>0</code> ，添加 <code>3</code> 个 <code>Apple</code>，价格为 <code>10</code>，保质期为 <code>10</code>。<br><code>sys.sell(1,&quot;Tom&quot;,&quot;Apple&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>1</code> ，用户 <code>Tom</code> 购买 <code>1</code> 个 <code>Apple</code>， 支付 <code>10</code> ：。<br><code>sys.sell(2,&quot;Tom&quot;,&quot;Apple&quot;,3);</code> &#x2F;&#x2F; 时刻 <code>2</code> ，售货机中 <code>Apple</code> 数量为 <code>2</code> ，用户 <code>Tom</code> 购买失败，返回 <code>-1</code>。<br><code>sys.sell(3,&quot;Mary&quot;,&quot;Banana&quot;,2);</code> &#x2F;&#x2F; 时刻 <code>3</code> ，售货机中没有 <code>Banana</code> ，用户 <code>Mary</code> 购买失败，返回 <code>-1</code>。<br><code>sys.sell(11,&quot;Jim&quot;,&quot;Apple&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>11</code> ，售货机中的 <code>Apple</code> 全部过期，用户 <code>Jim</code> 购买失败，返回 <code>-1</code>。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<br><code>[&quot;VendingMachine&quot;,&quot;addItem&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;sell&quot;]</code><br><code>[[],[0,1,&quot;Apple&quot;,4,3],[1,3,&quot;Apple&quot;,4,2],[2,&quot;Mary&quot;,&quot;Apple&quot;,2],[2,1,&quot;Banana&quot;,2,5],[4,&quot;Jim&quot;,&quot;Banana&quot;,2],[4,&quot;Mary&quot;,&quot;Banana&quot;,1],[4,&quot;Mary&quot;,&quot;Apple&quot;,1],[6,200,&quot;Apple&quot;,2,5],[6,&quot;Jim&quot;,&quot;Apple&quot;,100],[7,&quot;Mary&quot;,&quot;Apple&quot;,100]]</code></p>
<p>输出: <code>[null,null,null,8,null,-1,2,-1,null,200,196]</code></p>
<p>解释：<br><code>VendingMachine sys = new VendingMachine();</code><br><code>sys.addItem(0,1,&quot;Apple&quot;,4,3);</code> &#x2F;&#x2F; 时刻 <code>0</code> ，添加 <code>1</code> 个 <code>Apple</code>，价格为 <code>4</code>，保质期为 <code>3</code>。<br><code>sys.addItem(1,3,&quot;Apple&quot;,4,2);</code> &#x2F;&#x2F; 时刻 <code>1</code> ，添加 <code>3</code> 个 <code>Apple</code>，价格为 <code>4</code>，保质期为 <code>2</code>。<br><code>sys.sell(2,&quot;Mary&quot;,&quot;Apple&quot;,2);</code> &#x2F;&#x2F; 时刻 <code>2</code> ，用户 <code>Mary</code> 购买 <code>2</code> 个 <code>Apple</code>，支付 <code>8</code>。<br><code>sys.addItem(2,1,&quot;Banana&quot;,2,5);</code> &#x2F;&#x2F; 时刻 <code>2</code> ，添加 <code>1</code> 个 <code>Banana</code>，价格为 <code>2</code>，保质期为 <code>5</code>。<br><code>sys.sell(4,&quot;Jim&quot;,&quot;Banana&quot;,2);</code> &#x2F;&#x2F; 时刻 <code>4</code> ，售货机中 <code>Banana</code> 数量为 <code>1</code> ，用户 <code>Jim</code> 购买失败，返回 <code>-1</code>。<br><code>sys.sell(4,&quot;Mary&quot;,&quot;Banana&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>4</code> ，用户 <code>Mary</code> 购买 <code>1</code> 个 <code>Banana</code>，享受 1% 的优惠，向上取整后为 <code>2</code><br><code>sys.sell(4,&quot;Mary&quot;,&quot;Apple&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>4</code> ，售货机中的 <code>Apple</code> 全部过期，用户 <code>Mary</code> 购买失败，返回 <code>-1</code>。<br><code>sys.addItem(6,200,&quot;Apple&quot;,2,5);</code> &#x2F;&#x2F; 时刻 <code>6</code> ，添加 <code>200</code> 个 <code>Apple</code>，价格为 <code>2</code>，保质期为 <code>5</code>。<br><code>sys.sell(6,&quot;Jim&quot;,&quot;Apple&quot;,100);</code> &#x2F;&#x2F; 时刻 <code>6</code> ，用户 <code>Jim</code> 购买 <code>100</code> 个 <code>Apple</code>。返回 200<br><code>sys.sell(7,&quot;Mary&quot;,&quot;Apple&quot;,100);</code> &#x2F;&#x2F; 时刻 <code>7</code> ，用户 <code>Mary</code> 购买 <code>100</code> 个 <code>Apple</code>，可享受 2% 的优惠。返回196</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= item.length,customer.length &lt;= 10</code>，<code>item</code> 和 <code>customer</code> 中只包含英文字母</li>
<li><code>1 &lt;= duration,price,number &lt;= 10^6</code></li>
<li><code>0 &lt;= time &lt;= 10^6</code></li>
<li><code>addItem</code> 和 <code>sell</code> 的总调用次数不超过 <code>1000</code> 次</li>
</ul>
<p>关键是如何高效存储信息。</p>
<p>因为不能出售过期商品，而且售卖时间是递增的，所以每次售卖遍历过期商品的操作是多余，我们可以在售卖前删除过期商品，删除后本次遍历的商品都是可以购买的，不用担心过期问题。为了方便的去掉过期商品，可以创建<code>tuple&lt;time, item, price</code>小根堆，堆内会依次对关键词排序，实际我们只关心<code>time</code>，去除的时候只需要挨个遍历，堆内的<code>time</code>是递增的；</p>
<p>出售时，获取<code>item</code>在不同<code>&#123;end_time, price&#125;</code>的数量，可以用<code>map</code>来存储；</p>
<p>因为只有数量够客户的购买量，才会更新<code>item</code>的信息，如果在最后一步才发现数量不够，还需要回退更新操作，比较麻烦，而且时间上可能会超时，所以用<code>map</code>标记一下每个<code>item</code>的总量，如果数量够则放心更新信息，不够则直接返回<code>-1</code>；</p>
<p>因为客户每成功购买一次商品折扣就要少一个点，所以用<code>map</code>标记一下<code>customer</code>成功购买次数；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VendingMachine</span> &#123;</span><br><span class="line">    priority_queue&lt;tuple&lt;<span class="type">int</span>, string, <span class="type">int</span>&gt;, vector&lt;tuple&lt;<span class="type">int</span>, string, <span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt; item_time;</span><br><span class="line">    map&lt;string, map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt;&gt; item_info; </span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; user_cnt;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; item_cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VendingMachine</span>() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addItem</span><span class="params">(<span class="type">int</span> time, <span class="type">int</span> number, string item, <span class="type">int</span> price, <span class="type">int</span> duration)</span> </span>&#123;</span><br><span class="line">        item_time.<span class="built_in">push</span>(<span class="built_in">make_tuple</span>(time + duration, item, price));</span><br><span class="line">        item_info[item][<span class="built_in">make_pair</span>(price, time + duration)] += number;</span><br><span class="line">        item_cnt[item] += number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sell</span><span class="params">(<span class="type">int</span> time, string customer, string item, <span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!item_time.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(item_time.<span class="built_in">top</span>()) &lt; time) &#123;</span><br><span class="line">            <span class="type">int</span> _time = <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(item_time.<span class="built_in">top</span>());</span><br><span class="line">            string _item = <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(item_time.<span class="built_in">top</span>());</span><br><span class="line">            <span class="type">int</span> _price = <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(item_time.<span class="built_in">top</span>());</span><br><span class="line">            item_cnt[_item] -= item_info[_item][<span class="built_in">make_pair</span>(_price, _time)];</span><br><span class="line">            item_info[_item].<span class="built_in">erase</span>(<span class="built_in">make_pair</span>(_price, _time));</span><br><span class="line">            item_time.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(item_cnt[item] &lt; number) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> buy_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> price = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(buy_cnt &lt; number) &#123;</span><br><span class="line">            <span class="type">int</span> _price = item_info[item].<span class="built_in">begin</span>() -&gt; first.first;</span><br><span class="line">            <span class="type">int</span> _time = item_info[item].<span class="built_in">begin</span>() -&gt; first.second;</span><br><span class="line">            <span class="type">int</span> _num = item_info[item].<span class="built_in">begin</span>() -&gt; second;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;_num &quot; &lt;&lt; _num &lt;&lt; &quot; &quot;;</span></span><br><span class="line">            item_info[item].<span class="built_in">erase</span>(<span class="built_in">make_pair</span>(_price, _time));</span><br><span class="line">            <span class="type">int</span> cnt = <span class="built_in">min</span>(number - buy_cnt, _num);</span><br><span class="line">            buy_cnt += cnt;</span><br><span class="line">            price += <span class="number">1ll</span> * cnt * _price;</span><br><span class="line">            <span class="keyword">if</span>(_num &gt; cnt) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;item_info[item][make_pair(_price, _time)] &quot; &lt;&lt; item_info[item][make_pair(_price, _time)] &lt;&lt; endl;</span></span><br><span class="line">                item_info[item][<span class="built_in">make_pair</span>(_price, _time)] = _num - cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        item_cnt[item] -= number;</span><br><span class="line">        price = (price * <span class="built_in">max</span>(<span class="number">70</span>, (<span class="number">100</span> - user_cnt[customer])) - <span class="number">1</span>) * <span class="number">0.01</span> + <span class="number">1</span>;</span><br><span class="line">        user_cnt[customer] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your VendingMachine object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * VendingMachine* obj = new VendingMachine();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addItem(time,number,item,price,duration);</span></span><br><span class="line"><span class="comment"> * long long param_2 = obj-&gt;sell(time,customer,item,number);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>leetcode第331场周赛</title>
    <url>/2022/09/19/leetcode%E7%AC%AC311%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="最小偶倍数"><a href="#最小偶倍数" class="headerlink" title="最小偶倍数"></a>最小偶倍数</h2><p>给你一个正整数 <code>n</code> ，返回 <code>2</code> 和 <code>n</code> 的最小公倍数（正整数）。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：n &#x3D; 5<br>输出：10<br>解释：5 和 2 的最小公倍数是 10 。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：n &#x3D; 6<br>输出：6<br>解释：6 和 2 的最小公倍数是 6 。注意数字会是它自身的倍数。</p>
</blockquote>
<p>提示</p>
<blockquote>
<p>1 &lt;&#x3D; n &lt;&#x3D; 150</p>
</blockquote>
<p>直接gcd就可以，但是有一个数是2是确定的，这个2比较特殊。所以有另一种写法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y == <span class="number">0</span> ? x : <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestEvenMultiple</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="number">2</span> / <span class="built_in">gcd</span>(<span class="number">2</span>, n); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestEvenMultiple</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span>) <span class="keyword">return</span> n * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="最长的字母序连续字符串的长度"><a href="#最长的字母序连续字符串的长度" class="headerlink" title="最长的字母序连续字符串的长度"></a>最长的字母序连续字符串的长度</h2><p><strong>字母序连续字符串</strong> 是由字母表中连续字母组成的字符串。换句话说，字符串</p>
<blockquote>
<p>“abcdefghijklmnopqrstuvwxyz”</p>
</blockquote>
<p>的任意字符串都是<strong>字母序连续字符串</strong> 。</p>
<ul>
<li>例如，”abc” 是一个字母序连续字符串，而 “acb” 和 “za” 不是。</li>
<li>给你一个仅由小写英文字母组成的字符串 s ，返回其 最长 的 字母序连续子字符串 的长度。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：s &#x3D; “abacaba”<br>输出：2<br>解释：共有 4 个不同的字母序连续子字符串 “a”、”b”、”c” 和 “ab” 。<br>“ab” 是最长的字母序连续子字符串。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：s &#x3D; “abcde”<br>输出：5<br>解释：”abcde” 是最长的字母序连续子字符串。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<p>直接比较一下就行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestContinuousSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mxlen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] - s[i - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                mxlen++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, mxlen);</span><br><span class="line">                mxlen = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ans, mxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="翻转二叉树的奇数层"><a href="#翻转二叉树的奇数层" class="headerlink" title="翻转二叉树的奇数层"></a>翻转二叉树的奇数层</h2><p>给你一棵<strong>完美</strong>二叉树的根节点 root ，请你反转这棵树中每个<strong>奇数</strong>层的节点值。</p>
<ul>
<li>例如，假设第 3 层的节点值是 [2,1,3,4,7,11,29,18] ，那么反转后它应该变成 [18,29,11,7,4,3,1,2] 。<br>  反转后，返回树的根节点。</li>
</ul>
<p><strong>完美</strong>二叉树需满足：二叉树的所有父节点都有两个子节点，且所有叶子节点都在同一层。</p>
<p>节点的<strong>层数</strong>等于该节点到根节点之间的边数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/07/28/first_case1.png" alt="img"></p>
<blockquote>
<p>输入：root &#x3D; [2,3,5,8,13,21,34]<br>输出：[2,5,3,8,13,21,34]<br>解释：<br>这棵树只有一个奇数层。<br>在第 1 层的节点分别是 3、5 ，反转后为 5、3 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/07/28/second_case3.png" alt="img"></p>
<blockquote>
<p>输入：root &#x3D; [7,13,11]<br>输出：[7,11,13]<br>解释：<br>在第 1 层的节点分别是 13、11 ，反转后为 11、13 。 </p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数目在范围 <code>[1, 214]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 105</code></li>
<li><code>root</code> 是一棵 <strong>完美</strong> 二叉树</li>
</ul>
<p><strong>DFS</strong>，搜的时候把当前深度传进去，如果当前深度是基数，交换两个节点的val。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* left, TreeNode* right, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!left) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(d % <span class="number">2</span>) <span class="built_in">swap</span>(left-&gt;val, right-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(left-&gt;left, right-&gt;right, d + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(left-&gt;right, right-&gt;left, d + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reverseOddLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, root-&gt;right, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="字符串的前缀分数和"><a href="#字符串的前缀分数和" class="headerlink" title="字符串的前缀分数和"></a>字符串的前缀分数和</h2><p>给你一个长度为 n 的数组 words ，该数组由<strong>非空</strong>字符串组成。</p>
<p>定义字符串 word 的<strong>分数</strong>等于以 word 作为 前缀 的 words[i] 的数目。</p>
<ul>
<li>例如，如果 words &#x3D; [“a”, “ab”, “abc”, “cab”] ，那么 “ab” 的分数是 2 ，因为 “ab” 是 “ab” 和 “abc” 的一个前缀。</li>
</ul>
<p>返回一个长度为 n 的数组 answer ，其中 answer[i] 是 words[i] 的每个非空前缀的分数 总和 。</p>
<p><strong>注意</strong>：字符串视作它自身的一个前缀。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：words &#x3D; [“abc”,”ab”,”bc”,”b”]<br>输出：[5,4,3,2]<br>解释：对应每个字符串的答案如下：</p>
<p>“abc” 有 3 个前缀：”a”、”ab” 和 “abc” 。</p>
<p>2 个字符串的前缀为 “a” ，2 个字符串的前缀为 “ab” ，1 个字符串的前缀为 “abc” 。<br>总计 answer[0] &#x3D; 2 + 2 + 1 &#x3D; 5 。</p>
<p>“ab” 有 2 个前缀：”a” 和 “ab” 。</p>
<p>2 个字符串的前缀为 “a” ，2 个字符串的前缀为 “ab” 。<br>总计 answer[1] &#x3D; 2 + 2 &#x3D; 4 。</p>
<p>“bc” 有 2 个前缀：”b” 和 “bc” 。</p>
<p>2 个字符串的前缀为 “b” ，1 个字符串的前缀为 “bc” 。<br>总计 answer[2] &#x3D; 2 + 1 &#x3D; 3 。</p>
<p>“b” 有 1 个前缀：”b”。</p>
<p>2 个字符串的前缀为 “b” 。<br>总计 answer[3] &#x3D; 2 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：words &#x3D; [“abcd”]<br>输出：[4]<br>解释：<br>“abcd” 有 4 个前缀 “a”、”ab”、”abc” 和 “abcd”。<br>每个前缀的分数都是 1 ，总计 answer[0] &#x3D; 1 + 1 + 1 + 1 &#x3D; 4 。</p>
</blockquote>
<p>建<strong>Trie</strong>，统计。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> tr[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; word)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> u = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!tr[p][u]) &#123;</span><br><span class="line">                tr[p][u] = ++idx;</span><br><span class="line">            &#125;</span><br><span class="line">            p = tr[p][u];</span><br><span class="line">            cnt[p]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string&amp; word)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> u = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            p = tr[p][u];</span><br><span class="line">            res += cnt[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sumPrefixScores</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(tr, <span class="number">0</span> , <span class="keyword">sizeof</span> tr);</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        <span class="keyword">for</span>(string&amp; word : words) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(string&amp; word : words) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">query</span>(word));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Trie</tag>
        <tag>Binary tree</tag>
        <tag>Number Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>第313场周赛</title>
    <url>/2022/10/02/leetcode%E7%AC%AC313%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="公因子的数目"><a href="#公因子的数目" class="headerlink" title="公因子的数目"></a><a href="https://leetcode.cn/problems/number-of-common-factors/">公因子的数目</a></h2><p>给你两个正整数 <code>a</code> 和 <code>b</code> ，返回 <code>a</code> 和 <code>b</code> 的 <strong>公</strong> 因子的数目。</p>
<p>如果 <code>x</code> 可以同时整除 <code>a</code> 和 <code>b</code> ，则认为 <code>x</code> 是 <code>a</code> 和 <code>b</code> 的一个 <strong>公因子</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：a = 12, b = 6</span><br><span class="line">输出：4</span><br><span class="line">解释：12 和 6 的公因子是 1、2、3、6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：a = 25, b = 30</span><br><span class="line">输出：2</span><br><span class="line">解释：25 和 30 的公因子是 1、5 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= a, b &lt;= 1000</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">commonFactors</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a % i == <span class="number">0</span> &amp;&amp; b % i == <span class="number">0</span>) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="沙漏的最大总和"><a href="#沙漏的最大总和" class="headerlink" title="沙漏的最大总和"></a><a href="https://leetcode.cn/problems/maximum-sum-of-an-hourglass/">沙漏的最大总和</a></h2><p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>grid</code> 。</p>
<p>按以下形式将矩阵的一部分定义为一个 <strong>沙漏</strong> ：</p>
<p><img src="https://assets.leetcode.com/uploads/2022/08/21/img.jpg" alt="img"></p>
<p>返回沙漏中元素的 <strong>最大</strong> 总和。</p>
<p><strong>注意：</strong>沙漏无法旋转且必须整个包含在矩阵中。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/08/21/1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]</span><br><span class="line">输出：30</span><br><span class="line">解释：上图中的单元格表示元素总和最大的沙漏：6 + 2 + 1 + 2 + 9 + 2 + 8 = 30 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/08/21/2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：35</span><br><span class="line">解释：上图中的单元格表示元素总和最大的沙漏：1 + 2 + 3 + 5 + 7 + 8 + 9 = 35 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>3 &lt;= m, n &lt;= 150</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 106</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; m - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> s = grid[i][j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j - <span class="number">1</span>; k &lt; j - <span class="number">1</span> + <span class="number">3</span>; k++) &#123;</span><br><span class="line">                    s += grid[i - <span class="number">1</span>][k] + grid[i + <span class="number">1</span>][k];</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="最小-XOR"><a href="#最小-XOR" class="headerlink" title="最小 XOR"></a><a href="https://leetcode.cn/problems/minimize-xor/">最小 XOR</a></h2><p>给你两个正整数 <code>num1</code> 和 <code>num2</code> ，找出满足下述条件的整数 <code>x</code> ：</p>
<ul>
<li><code>x</code> 的置位数和 <code>num2</code> 相同，且</li>
<li><code>x XOR num1</code> 的值 <strong>最小</strong></li>
</ul>
<p>注意 <code>XOR</code> 是按位异或运算。</p>
<p>返回整数 <code>x</code> 。题目保证，对于生成的测试用例， <code>x</code> 是 <strong>唯一确定</strong> 的。</p>
<p>整数的 <strong>置位数</strong> 是其二进制表示中 <code>1</code> 的数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num1 = 3, num2 = 5</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">num1 和 num2 的二进制表示分别是 0011 和 0101 。</span><br><span class="line">整数 3 的置位数与 num2 相同，且 3 XOR 3 = 0 是最小的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num1 = 1, num2 = 12</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">num1 和 num2 的二进制表示分别是 0001 和 1100 。</span><br><span class="line">整数 3 的置位数与 num2 相同，且 3 XOR 1 = 2 是最小的。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num1, num2 &lt;= 109</code></li>
</ul>
<p>位运算，<code>^</code>运算相同为0，不同为1，要让最终的<code>^</code>结果最小，用尽量多的<code>1</code>从高位开始去占高位的<code>1</code>，这样会抹掉高位的<code>1</code>，如果还有多余的<code>1</code>，那就从低位开始，占低位的<code>0</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimizeXor</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num2 &amp; <span class="number">1</span>) cnt++;</span><br><span class="line">            num2 &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span> &amp;&amp; cnt &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num1 &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span> &amp;&amp; cnt &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(num1 &gt;&gt; i &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="对字母串可执行的最大删除数"><a href="#对字母串可执行的最大删除数" class="headerlink" title="对字母串可执行的最大删除数"></a>对字母串可执行的最大删除数</h2><p>给你一个仅由小写英文字母组成的字符串 <code>s</code> 。在一步操作中，你可以：</p>
<ul>
<li>删除 <strong>整个字符串</strong> <code>s</code> ，或者</li>
<li>对于满足 <code>1 &lt;= i &lt;= s.length / 2</code> 的任意 <code>i</code> ，如果 <code>s</code> 中的 <strong>前</strong> <code>i</code> 个字母和接下来的 <code>i</code> 个字母 <strong>相等</strong> ，删除 <strong>前</strong> <code>i</code> 个字母。</li>
</ul>
<p>例如，如果 <code>s = &quot;ababc&quot;</code> ，那么在一步操作中，你可以删除 <code>s</code> 的前两个字母得到 <code>&quot;abc&quot;</code> ，因为 <code>s</code> 的前两个字母和接下来的两个字母都等于 <code>&quot;ab&quot;</code> 。</p>
<p>返回删除 <code>s</code> 所需的最大操作数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcabcdabc&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">- 删除前 3 个字母（&quot;abc&quot;），因为它们和接下来 3 个字母相等。现在，s = &quot;abcdabc&quot;。</span><br><span class="line">- 删除全部字母。</span><br><span class="line">一共用了 2 步操作，所以返回 2 。可以证明 2 是所需的最大操作数。</span><br><span class="line">注意，在第二步操作中无法再次删除 &quot;abc&quot; ，因为 &quot;abc&quot; 的下一次出现并不是位于接下来的 3 个字母。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aaabaab&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">- 删除第一个字母（&quot;a&quot;），因为它和接下来的字母相等。现在，s = &quot;aabaab&quot;。</span><br><span class="line">- 删除前 3 个字母（&quot;aab&quot;），因为它们和接下来 3 个字母相等。现在，s = &quot;aab&quot;。 </span><br><span class="line">- 删除第一个字母（&quot;a&quot;），因为它和接下来的字母相等。现在，s = &quot;ab&quot;。</span><br><span class="line">- 删除全部字母。</span><br><span class="line">一共用了 4 步操作，所以返回 4 。可以证明 4 是所需的最大操作数。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aaaaa&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：在每一步操作中，都可以仅删除 s 的第一个字母。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 4000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<p>字符串哈希，线性动态规划。</p>
<p>用字符串<code>hash</code>通过<code>O(n^2)</code>的预处理，可以在<code>O(1)</code>的时间内查询两个字符串是否相同。</p>
<p><code>f[i]</code>表示删掉<code>i</code>后缀用的最大操作次数。</p>
<p>枚举后缀长度<code>j</code>，如果<code>i</code>开始长度为<code>j</code>的字符串可以删除，</p>
<p>表示<code>[i, i + j - 1]</code>和<code>[i + j, i + j + j -1]</code>的字符串是相同的，</p>
<p>那么后缀<code>i</code>的删除次数可以增加一次，可以更新最大删除次数：<code>f[i] = max(f[i], f[i + j] + 1)</code>，</p>
<p>对每一个<code>i</code>枚举所有合法的长度<code>j</code>，取最大值，便是<code>f[i]</code>，删除<code>i</code>后缀的最大操作次数。</p>
<p>时间复杂度为<code>O(n^2)</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> P = <span class="number">131</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> h[<span class="number">4005</span>], p[<span class="number">4005</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">            h[i] = h[i - <span class="number">1</span>] * P + s[i - <span class="number">1</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            f[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= (n - i + <span class="number">1</span>) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">get</span>(i, i + j - <span class="number">1</span>) == <span class="built_in">get</span>(i + j, i + j + j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    f[i] = <span class="built_in">max</span>(f[i], f[i + j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">1</span>];    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>家谱树</title>
    <url>/2022/11/07/%E5%AE%B6%E8%B0%B1%E6%A0%91/</url>
    <content><![CDATA[<p>有个人的家族很大，辈分关系很混乱，请你帮整理一下这种关系。</p>
<p>给出每个人的孩子的信息。</p>
<p>输出一个序列，使得每个人的孩子都比那个人后列出。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第 1 行一个整数 n ，表示家族的人数；</p>
<p>接下来 n 行，第 i 行描述第 i 个人的孩子；</p>
<p>每行最后是 0 表示描述完毕。</p>
<p>每个人的编号从 1 到 n。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个序列，使得每个人的孩子都比那个人后列出；</p>
<p>数据保证一定有解，如果有多解输出任意一解。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 &lt;&#x3D; n &lt;&#x3D; 100</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">0</span><br><span class="line">4 5 1 0</span><br><span class="line">1 0</span><br><span class="line">5 3 0</span><br><span class="line">3 0</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 4 5 3 1</span><br></pre></td></tr></table></figure>

<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p>邻接表存图，先把入度为0的点进队列，然后不断的取出队列的头结点，每次将头结点的所连的节点的入度减一，如果所连节点的度数减少为0，则将此节点进入队列，直到队列为空。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>, M = N * N / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[idx] = y, ne[idx] = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!d[i]) q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line">        <span class="type">int</span> x = q[hh++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; ~i; i = ne[i]) &#123;</span><br><span class="line">            <span class="type">int</span> y = e[i];</span><br><span class="line">            <span class="keyword">if</span> (--d[y] == <span class="number">0</span>) q[++tt] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> son;</span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; son, son) &#123;</span><br><span class="line">            <span class="built_in">add</span>(i, son);</span><br><span class="line">            d[son]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>滑雪车</title>
    <url>/2022/11/08/%E6%BB%91%E9%9B%AA%E8%BD%A6/</url>
    <content><![CDATA[<p>随着白天越来越短夜晚越来越长，我们不得不考虑铲雪问题了。</p>
<p>整个城市所有的道路都是双向车道,道路的两个方向均需要铲雪。因为城市预算的削减，整个城市只有 1 辆铲雪车。</p>
<p>铲雪车只能把它开过的地方（车道）的雪铲干净，无论哪儿有雪，铲雪车都得从停放的地方出发，游历整个城市的街道。</p>
<p>现在的问题是：最少要花多少时间去铲掉所有道路上的雪呢？</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入数据的第$1$行表示铲雪车的停放坐标$(x,y)$，$x$，$y$为整数，单位为米。</p>
<p>下面最多有$4000$行，每行给出了一条街道的起点坐标和终点坐标，坐标均为整数，所有街道都是笔直的，且都是双向车道。</p>
<p>铲雪车可以在任意交叉口、或任何街道的末尾任意转向，包括转$U$型弯。</p>
<p>铲雪车铲雪时前进速度为 $20$千米&#x2F;时，不铲雪时前进速度为$50$千米&#x2F;时。</p>
<p>保证：铲雪车从起点一定可以到达任何街道。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出铲掉所有街道上的雪并且返回出发点的最短时间，精确到分钟，四舍五入到整数。</p>
<p>输出格式为$hours:minutes$，$minutes$不足两位数时需要补前导零。<br>具体格式参照样例。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$−10^6\leq x, y≤10^6$<br>所有位置坐标绝对值不超过 $10^6$</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0</span><br><span class="line">0 0 10000 10000</span><br><span class="line">5000 -10000 5000 10000</span><br><span class="line">5000 10000 10000 10000</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3:55</span><br></pre></td></tr></table></figure>

<h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>输出结果表示共需3小时55分钟。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>这个题貌似很复杂，其实可以发现每条路都是双向通路，所以存在欧拉回路，意味着我们可以选择任意一点作为起始点，不重不漏的走完所有的边再回到起点，然后反向再走一遍就可以打扫完所有的积雪。</p>
<p>可以发现$50$千米&#x2F;小时的速度用不上，$50$千米&#x2F;小时的速度必须是行驶在一条没有雪的边上才可以达到的，意味着这条边已经来回走了一遍。但是我们从起点走到起点，再从起点反着走到起点就已经把所有的道路积雪清理完毕，自始至终都是以$20$千米&#x2F;小时的速度前进。</p>
<p>故求出所有边的长度 * $2$ 就是行驶距离，然后再进行小时和分钟的计算。</p>
<p>有向图中<strong>欧拉回路</strong>存在的充要条件是所有点的出度等于入度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> x1, y1, x2, y2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>, &amp;x1, &amp;y1);</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf %lf&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2)) &#123;</span><br><span class="line">        <span class="type">double</span> dx = x1 - x2;</span><br><span class="line">        <span class="type">double</span> dy = y1 - y2;</span><br><span class="line">        sum += <span class="built_in">sqrt</span>(dx * dx + dy * dy) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> minutes = <span class="built_in">round</span>(sum / <span class="number">1000</span> / <span class="number">20</span> * <span class="number">60</span>);</span><br><span class="line">    <span class="type">int</span> hours = minutes / <span class="number">60</span>;</span><br><span class="line">    minutes %= <span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%02d\n&quot;</span>, hours, minutes);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode第319场周赛</title>
    <url>/2022/11/16/leetcode%E7%AC%AC319%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h3 id="温度转换"><a href="#温度转换" class="headerlink" title="温度转换"></a>温度转换</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给你一个四舍五入到两位小数的非负浮点数$$celsius$$来表示温度，以 <strong>摄氏度</strong>（<strong>Celsius</strong>）为单位。</p>
<p>你需要将摄氏度转换为 <strong>开氏度</strong>（<strong>Kelvin</strong>）和 <strong>华氏度</strong>（<strong>Fahrenheit</strong>），并以数组 $$ans &#x3D; [kelvin, fahrenheit]$$的形式返回结果。</p>
<p>返回数组 $$ans$$ 。与实际答案误差不超过 $$10^{-5}$$ 的会视为正确答案。</p>
<p><strong>注意：</strong></p>
<ul>
<li><code>开氏度 = 摄氏度 + 273.15</code></li>
<li><code>华氏度 = 摄氏度 * 1.80 + 32.00</code></li>
</ul>
<p><strong>示例 1 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：celsius = 36.50</span><br><span class="line">输出：[309.65000,97.70000]</span><br><span class="line">解释：36.50 摄氏度：转换为开氏度是 309.65 ，转换为华氏度是 97.70 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：celsius = 122.11</span><br><span class="line">输出：[395.26000,251.79800]</span><br><span class="line">解释：122.11 摄氏度：转换为开氏度是 395.26 ，转换为华氏度是 251.798 。</span><br></pre></td></tr></table></figure>

<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>模拟即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">convertTemperature</span><span class="params">(<span class="type">double</span> celsius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;celsius + <span class="number">273.15</span>, celsius * <span class="number">1.80</span> + <span class="number">32.00</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="最小公倍数为K的子数组数目"><a href="#最小公倍数为K的子数组数目" class="headerlink" title="最小公倍数为K的子数组数目"></a>最小公倍数为K的子数组数目</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <code>nums</code> 的 <strong>子数组</strong> 中满足 <em>元素最小公倍数为 <code>k</code></em> 的子数组数目。</p>
<p><strong>子数组</strong> 是数组中一个连续非空的元素序列。</p>
<p><strong>数组的最小公倍数</strong> 是可被所有数组元素整除的最小正整数。</p>
<p><strong>示例 1 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,6,2,7,1], k = 6</span><br><span class="line">输出：4</span><br><span class="line">解释：以 6 为最小公倍数的子数组是：</span><br><span class="line">- [3,6,2,7,1]</span><br><span class="line">- [3,6,2,7,1]</span><br><span class="line">- [3,6,2,7,1]</span><br><span class="line">- [3,6,2,7,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3], k = 2</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在以 2 为最小公倍数的子数组。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i], k &lt;= 1000</code></li>
</ul>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>$$nums[i]$$, $$nums[i + 1]$$, $$nums[i + 2]$$的最小公倍数等于$$(nums[i]与nums[i + 1])$$的最小公倍数与$$nums[i + 2]$$的最小公倍数，是一个传导的过程，若干数的最大公约数也是如此。</p>
<p>当最小公倍数大于$$k$$时，及时break，减少不必要的计算。</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarrayLCM</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> t = nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                t = t * nums[j] / <span class="built_in">gcd</span>(t, nums[j]);</span><br><span class="line">                <span class="keyword">if</span>(t == k) res++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(t &gt; k) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="逐层排序二叉树所需的最小操作数目"><a href="#逐层排序二叉树所需的最小操作数目" class="headerlink" title="逐层排序二叉树所需的最小操作数目"></a>逐层排序二叉树所需的最小操作数目</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>给你一个 <strong>值互不相同</strong> 的二叉树的根节点 <code>root</code> 。</p>
<p>在一步操作中，你可以选择 <strong>同一层</strong> 上任意两个节点，交换这两个节点的值。</p>
<p>返回每一层按 <strong>严格递增顺序</strong> 排序所需的最少操作数目。</p>
<p>节点的 <strong>层数</strong> 是该节点和根节点之间的路径的边数。</p>
<p><strong>示例 1 ：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/09/18/image-20220918174006-2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">- 交换 4 和 3 。第 2 层变为 [3,4] 。</span><br><span class="line">- 交换 7 和 5 。第 3 层变为 [5,6,8,7] 。</span><br><span class="line">- 交换 8 和 7 。第 3 层变为 [5,6,7,8] 。</span><br><span class="line">共计用了 3 步操作，所以返回 3 。</span><br><span class="line">可以证明 3 是需要的最少操作数目。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 ：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/09/18/image-20220918174026-3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,3,2,7,6,5,4]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">- 交换 3 和 2 。第 2 层变为 [2,3] 。 </span><br><span class="line">- 交换 7 和 4 。第 3 层变为 [4,6,5,7] 。 </span><br><span class="line">- 交换 6 和 5 。第 3 层变为 [4,5,6,7] 。</span><br><span class="line">共计用了 3 步操作，所以返回 3 。 </span><br><span class="line">可以证明 3 是需要的最少操作数目。</span><br></pre></td></tr></table></figure>

<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>此问题可以拆解成两个问题。第一个问题是二叉树的层序遍历，第二个问题是如何在交换次数尽量少的情况下使得数组有序。</p>
<p>层序遍历可以用$BFS$来实现。</p>
<p>第二个问题可以通过</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4>]]></content>
  </entry>
  <entry>
    <title>搭配购买</title>
    <url>/2023/02/01/%E6%90%AD%E9%85%8D%E8%B4%AD%E4%B9%B0/</url>
    <content><![CDATA[<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>Joe觉得云朵很美，决定去山上的商店买一些云朵。</p>
<p>商店里有 $n$朵云，云朵被编号为$1,2,…,n$，并且每朵云都有一个价值。</p>
<p>但是商店老板跟他说，一些云朵要搭配来买才好，所以买一朵云则与这朵云有搭配的云都要买。</p>
<p>但是Joe的钱有限，所以他希望买的价值越多越好。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第 11 行包含三个整数$ n，m，w$，表示有$n$朵云，$m$个搭配，Joe有$w$的钱。</p>
<p>第$2∼n+1$行，每行两个整数 $ci，di$，表示$ i$ 朵云的价钱和价值。</p>
<p>第$n+2∼n+1+m$行，每行两个整数$ui，vi$，表示买$ui$就必须买$vi$，同理，如果买$vi$就必须买$ui$。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>一行，表示可以获得的最大价值。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N], v[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != fa[x]) fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, _w;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; _w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(fx != fy) &#123;</span><br><span class="line">            w[fx] += w[fy];</span><br><span class="line">            v[fx] += v[fy];</span><br><span class="line">            fa[fy] = fx;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == fa[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = _w; j &gt;= w[i]; j--) &#123;</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[_w] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>并查集、01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap详解</title>
    <url>/2023/04/06/HashMap%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="HashMap的底层结构"><a href="#HashMap的底层结构" class="headerlink" title="HashMap的底层结构"></a>HashMap的底层结构</h3><p>jdk1.7中，HashMap是由数组加链表组成的，数组是主体，链表主要是为了解决hash冲突。</p>
<p>jdk1.8中，HashMap是由数组、链表加红黑树组成。当链表过长，则会严重影响HashMap的性能，红黑树的查询时间复杂度O(log n)，而链表的查询时间复杂度为O(n)。1.8中，链表和红黑树在达到一定条件会自动进行转换：</p>
<ul>
<li>当链表长度达到8时，且数据总量<code>&gt;=</code>64会转红黑树</li>
<li>当链表长度达到8时，数据总量<code>&lt;</code>64会直接扩容</li>
</ul>
<h3 id="HashMap的线程安全性"><a href="#HashMap的线程安全性" class="headerlink" title="HashMap的线程安全性"></a>HashMap的线程安全性</h3><h3 id="HashMap的key索引计算"><a href="#HashMap的key索引计算" class="headerlink" title="HashMap的key索引计算"></a>HashMap的key索引计算</h3><h3 id="HashMap的put操作"><a href="#HashMap的put操作" class="headerlink" title="HashMap的put操作"></a>HashMap的put操作</h3><h3 id="HashMap的get操作"><a href="#HashMap的get操作" class="headerlink" title="HashMap的get操作"></a>HashMap的get操作</h3><h3 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h3><h3 id="HashMap的冲突解决"><a href="#HashMap的冲突解决" class="headerlink" title="HashMap的冲突解决"></a>HashMap的冲突解决</h3><p>解决Hash冲突的办法有：</p>
<ul>
<li>开放地址法:</li>
<li>拉链法：使用链表等数据结构将哈希冲突的键值对连接在一起，当出现冲突时，将新的键值对插入到该位置对应的料表中。<ul>
<li>再哈希法：当哈希冲突发生时，选择另一个哈希函数来计算新哈希值，直到找到没有冲突的索引下标。需要设计多种哈希函数。</li>
</ul>
</li>
<li>建立公共溢出区：</li>
</ul>
<h3 id="HashMap的默认加载因子"><a href="#HashMap的默认加载因子" class="headerlink" title="HashMap的默认加载因子"></a>HashMap的默认加载因子</h3><h3 id="HashMap的Key类型选择"><a href="#HashMap的Key类型选择" class="headerlink" title="HashMap的Key类型选择"></a>HashMap的Key类型选择</h3><h3 id="HashMap为什么不直接用红黑树，而是先用链表再转红黑树"><a href="#HashMap为什么不直接用红黑树，而是先用链表再转红黑树" class="headerlink" title="HashMap为什么不直接用红黑树，而是先用链表再转红黑树"></a>HashMap为什么不直接用红黑树，而是先用链表再转红黑树</h3><h3 id="HashMap的长度为什么是2的幂次方"><a href="#HashMap的长度为什么是2的幂次方" class="headerlink" title="HashMap的长度为什么是2的幂次方"></a>HashMap的长度为什么是2的幂次方</h3><p>​	</p>
]]></content>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的锁</title>
    <url>/2023/04/18/Java%E4%B8%AD%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><h4 id="公平锁：线程A获取了锁资源之后，线程B没有拿到，线程B去排队，线程C来了，锁被A持有，同时线程B在排队，线程C直接排到线程B后面，等待线程B拿到锁资源或者B取消后，才尝试竞争锁资源"><a href="#公平锁：线程A获取了锁资源之后，线程B没有拿到，线程B去排队，线程C来了，锁被A持有，同时线程B在排队，线程C直接排到线程B后面，等待线程B拿到锁资源或者B取消后，才尝试竞争锁资源" class="headerlink" title="公平锁：线程A获取了锁资源之后，线程B没有拿到，线程B去排队，线程C来了，锁被A持有，同时线程B在排队，线程C直接排到线程B后面，等待线程B拿到锁资源或者B取消后，才尝试竞争锁资源"></a>公平锁：线程A获取了锁资源之后，线程B没有拿到，线程B去排队，线程C来了，锁被A持有，同时线程B在排队，线程C直接排到线程B后面，等待线程B拿到锁资源或者B取消后，才尝试竞争锁资源</h4><h4 id="非公平锁：线程A获取到了锁资源，线程B没有拿到，线程B去排队，线程C来了，先尝试竞争一下锁资源"><a href="#非公平锁：线程A获取到了锁资源，线程B没有拿到，线程B去排队，线程C来了，先尝试竞争一下锁资源" class="headerlink" title="非公平锁：线程A获取到了锁资源，线程B没有拿到，线程B去排队，线程C来了，先尝试竞争一下锁资源"></a>非公平锁：线程A获取到了锁资源，线程B没有拿到，线程B去排队，线程C来了，先尝试竞争一下锁资源</h4><blockquote>
<h4 id="拿到锁资源：插队成功"><a href="#拿到锁资源：插队成功" class="headerlink" title="拿到锁资源：插队成功"></a>拿到锁资源：插队成功</h4><h4 id="没有拿到锁资源：依然要排到线程B后面，等线程B拿到锁资源或者取消，才尝试去竞争锁资源"><a href="#没有拿到锁资源：依然要排到线程B后面，等线程B拿到锁资源或者取消，才尝试去竞争锁资源" class="headerlink" title="没有拿到锁资源：依然要排到线程B后面，等线程B拿到锁资源或者取消，才尝试去竞争锁资源"></a>没有拿到锁资源：依然要排到线程B后面，等线程B拿到锁资源或者取消，才尝试去竞争锁资源</h4></blockquote>
<blockquote>
<p>Java提供的synchronized只能是非公平锁</p>
<p>Java提供的ReentrantLock、ReentrantReadWriteLock可以实现公平锁和非公平锁</p>
</blockquote>
<h3 id="可重入锁与不可重入锁"><a href="#可重入锁与不可重入锁" class="headerlink" title="可重入锁与不可重入锁"></a>可重入锁与不可重入锁</h3><h4 id="可重入：当前线程获取A锁之后，在获取之后尝试再次获取A锁是可以直接拿到的"><a href="#可重入：当前线程获取A锁之后，在获取之后尝试再次获取A锁是可以直接拿到的" class="headerlink" title="可重入：当前线程获取A锁之后，在获取之后尝试再次获取A锁是可以直接拿到的"></a>可重入：当前线程获取A锁之后，在获取之后尝试再次获取A锁是可以直接拿到的</h4><h4 id="不可重入：当前线程获取A锁之后，尝试再次获取A锁是无法获取到的。"><a href="#不可重入：当前线程获取A锁之后，尝试再次获取A锁是无法获取到的。" class="headerlink" title="不可重入：当前线程获取A锁之后，尝试再次获取A锁是无法获取到的。"></a>不可重入：当前线程获取A锁之后，尝试再次获取A锁是无法获取到的。</h4><blockquote>
<p>Java中的synchronized，ReentrantLock，ReentrantReadWriteLock都是可重入式锁</p>
</blockquote>
<h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><h4 id="悲观锁：获取不到锁资源的时候会将当前线程挂起，线程挂起会涉及到用户态和内核态之间的切换，这种切换是非常消耗资源的。"><a href="#悲观锁：获取不到锁资源的时候会将当前线程挂起，线程挂起会涉及到用户态和内核态之间的切换，这种切换是非常消耗资源的。" class="headerlink" title="悲观锁：获取不到锁资源的时候会将当前线程挂起，线程挂起会涉及到用户态和内核态之间的切换，这种切换是非常消耗资源的。"></a>悲观锁：获取不到锁资源的时候会将当前线程挂起，线程挂起会涉及到用户态和内核态之间的切换，这种切换是非常消耗资源的。</h4><h4 id="线程切换引起内核态切换的原因？"><a href="#线程切换引起内核态切换的原因？" class="headerlink" title="线程切换引起内核态切换的原因？"></a>线程切换引起内核态切换的原因？</h4><p>当一个线程需要访问内核资源时，需要通过系统调用进入内核态来访问内核资源，比如IO操作。如果此时线程被挂起，会从内核态切回用户态，当挂起线程被重新唤醒，它将再次进入内核态。</p>
<blockquote>
<h4 id="用户态和内核态转换需要消耗的资源？"><a href="#用户态和内核态转换需要消耗的资源？" class="headerlink" title="用户态和内核态转换需要消耗的资源？"></a>用户态和内核态转换需要消耗的资源？</h4><p>1、CPU时间：在用户态和内核态进行切换时，CPU需要执行额外的指令，包括保存和恢复现场，这些指令会占用CPU时间，导致性能下降</p>
<p>2、上下文切换开销：当操作系统在不同的线程进行切换时，需要上下文切换，这会涉及到保存当前线程的上下文，然后加载新线程的上下文。</p>
</blockquote>
<h4 id="乐观锁：获取不到锁资源，可再次尝试让CPU调度，重新获取锁资源"><a href="#乐观锁：获取不到锁资源，可再次尝试让CPU调度，重新获取锁资源" class="headerlink" title="乐观锁：获取不到锁资源，可再次尝试让CPU调度，重新获取锁资源"></a>乐观锁：获取不到锁资源，可再次尝试让CPU调度，重新获取锁资源</h4><blockquote>
<p>Java提供的CAS操作就是一种乐观锁的一种实现方式 </p>
<p>Atomic原子类中也是基于CAS乐观锁来实现的</p>
</blockquote>
<h3 id="互斥锁与共享锁"><a href="#互斥锁与共享锁" class="headerlink" title="互斥锁与共享锁"></a>互斥锁与共享锁</h3><h4 id="互斥锁：同一个时间，只会有一个线程持有当前互斥锁"><a href="#互斥锁：同一个时间，只会有一个线程持有当前互斥锁" class="headerlink" title="互斥锁：同一个时间，只会有一个线程持有当前互斥锁"></a>互斥锁：同一个时间，只会有一个线程持有当前互斥锁</h4><h4 id="共享锁：同一个时间，当前共享锁可以被多个线程同时持有"><a href="#共享锁：同一个时间，当前共享锁可以被多个线程同时持有" class="headerlink" title="共享锁：同一个时间，当前共享锁可以被多个线程同时持有"></a>共享锁：同一个时间，当前共享锁可以被多个线程同时持有</h4><blockquote>
<p>共享锁一般配置读写锁来实现的，读写锁互斥，读读锁共享</p>
</blockquote>
<blockquote>
<p>Java提供的sychnronized、ReentrantLock是互斥锁</p>
<p>Java提供的ReentrantReadWriteLock有互斥锁也有共享锁</p>
</blockquote>
]]></content>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
</search>
